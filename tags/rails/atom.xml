<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: rails | loop in codes]]></title>
  <link href="http://codemacro.com/tags/rails/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2012-08-02T10:41:38+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails中获取客户端时区]]></title>
    <link href="http://codemacro.com/2012/07/20/get-client-timezone-in-rails/"/>
    <updated>2012-07-20T16:42:00+08:00</updated>
    <id>http://codemacro.com/2012/07/20/get-client-timezone-in-rails</id>
    <content type="html"><![CDATA[<p>开发网站功能时，有时候需要获取客户端（浏览器）所在的时区，然后根据不同的时区做一些不同的逻辑功能。这里提供一种方法，其思路为客户端通过js获取时区，然后发送给服务器，服务器存储时区到session中。</p>

<p>{% highlight javascript %}
{% raw %}
function submit_timezone(url) {
  $.get(url, {'offset_min' : (-1 * (new Date()).getTimezoneOffset())});
}</p>

<p>$(document).ready(function() {</p>

<pre><code>submit_timezone('&lt;%= sys_timezone_path %&gt;');
</code></pre>

<p>});
{% endraw %}
{% endhighlight %}</p>

<!-- more -->


<p>sys_timezone_path是一个特地用来处理时区的route。其实主要需要的是offset_min这个请求参数，你可以把这个参数附加到其他请求里。</p>

<p>然后根据offset_min获取到时区名：</p>

<p>{% highlight ruby %}
def timezone
  offset_sec = params[:offset_min].to_i * 60
  zone = ActiveSupport::TimeZone[offset_sec]
  zone = ActiveSupport::TimeZone["UTC"] unless zone
  session[:zone_name] = zone.name if zone
  respond_to do |format|</p>

<pre><code>format.js
</code></pre>

<p>  end
end
{% endhighlight %}</p>

<p>以上，获取到时区名后存储到session[:zone_name]里。在之后处理这个客户端的请求时，就可以通过这个时区名取得对应的时区，例如：</p>

<p>{% highlight ruby %}
zone_name = session[:zone_name]
zone = ActiveSupport::TimeZone[zone_name] if zone_name
{% endhighlight %}</p>

<p>但经过我实际测试，部署在heroku上的应用偶尔会发现session[:zone_name]取出来是nil，尽管我确认了timezone函数是被调用过的。这难道跟session的超时有关？后来我只好将timezone name写到客户端页面中，然后在其他请求中再把这个时区名发回来。</p>
]]></content>
  </entry>
  
</feed>
