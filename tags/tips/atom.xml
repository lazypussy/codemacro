<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: tips | loop in codes]]></title>
  <link href="http://codemacro.com/tags/tips/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2012-08-02T10:41:38+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lua里实现简单的类-对象]]></title>
    <link href="http://codemacro.com/2012/08/02/simple-oo-in-lua/"/>
    <updated>2012-08-02T10:18:00+08:00</updated>
    <id>http://codemacro.com/2012/08/02/simple-oo-in-lua</id>
    <content type="html"><![CDATA[<p>要在Lua里实现面向对象有很多方法，为了支持面向对象的一些特性（类、对象、继承、重载等），其实现可能会比较复杂。看看云风的<a href="http://blog.codingnow.com/2006/06/oo_lua.html">这篇</a>，以及后面的评论，有总结的不错的。这真是让人对Lua刮目相看。但是我并不需要这些机制，一般情况下我只需要支持类即可。</p>

<p>类其实就是定义一个对象的函数模板，避免我写出带模块名并且第一个参数是操作对象的函数（像C一样）。以下代码提炼于rapanui（基于<a href="http://getmoai.com/">moai</a>的高层封装），摘抄于几个月前我基于rapanui移植到android上的一个<a href="https://github.com/kevinlynx/crazyeggs_mobile">小游戏</a>：</p>

<!-- more -->


<p>{% highlight lua %}
local function newindex(self, key, value)</p>

<pre><code>getmetatable(self).__object[key] = value
</code></pre>

<p>end</p>

<p>local function index(self, key)</p>

<pre><code>return getmetatable(self).__object[key]
</code></pre>

<p>end</p>

<p>function newObject(o, class)</p>

<pre><code>class.__index = class
setmetatable(o, class)
return setmetatable({}, { __newindex = newindex, __index = index, __object = o })
</code></pre>

<p>end
{% endhighlight %}</p>

<p>基于newObject函数，可以这样定义类：</p>

<p>{% highlight lua %}
Button = {}</p>

<p>function Button.new(text, x, y, onclick, parent)</p>

<pre><code>-- 定义这个类的数据成员
local obj = {
    text = text,
    onclick = onclick,
    normal_img = nil,
    text_inst = nil,
    hover_img = nil,
}
obj = newObject(obj, Button)
...
return obj
</code></pre>

<p>end</p>

<p>function Button:onTouchDown(x, y)</p>

<pre><code>...
-- 可以访问成员，即使看起来normal_img不属于Button这个table
self.normal_img.visible = true
</code></pre>

<p>end</p>

<p>function Button:onTouchUp(x, y)</p>

<pre><code>...
</code></pre>

<p>end
{% endhighlight %}</p>

<p>通过以上定义后，就可以以面向对象的方式来使用Button类了：</p>

<p>{% highlight lua %}
local btn = Button.new()
btn:OnTouchDown(100, 100)
btn:OnTouchUp(100, 100)
{% endhighlight %}</p>

<p>其实现原理，主要就是将类的函数集通过<code>__index</code>开放给对象，在这些函数中，其<code>self</code>就像c++ 中的<code>this</code>一样拥有多态性，即其是创建出来的对象，而不是作为类角色的那个<code>table</code>（例如Button）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[像写函数式语言代码一样写C++]]></title>
    <link href="http://codemacro.com/2012/07/30/write-cpp-like-fp/"/>
    <updated>2012-07-30T17:11:00+08:00</updated>
    <id>http://codemacro.com/2012/07/30/write-cpp-like-fp</id>
    <content type="html"><![CDATA[<p>忘记最早接触函数式编程语言是什么时候了，也忘记接触的第一门函数式语言是哪一门。断断续续接触过好几种函数式语言（当然都算不纯的，ruby/lisp不算纯吧），这些语言的思想在潜移默化中多多少少对我有所影响。</p>

<p>我是个C++程序员，我不知道我平时写的都是些什么代码。最让人印象深刻就是我会经常写遍历STL容器的代码，是经常，这样的遍历你可能也不陌生：</p>

<p>{% highlight c++ %}
{% raw %}
for (ListType::iterator it = con.begin(); it != con.end(); ++it) {</p>

<pre><code>something
</code></pre>

<p>}
{% endraw %}
{% endhighlight %}</p>

<!-- more -->


<p>或者针对std::map/set等的查找：</p>

<p>{% highlight c++ %}
{% raw %}
Table::iterator it = table.find(key);
if (it == table.end())</p>

<pre><code>do-something
</code></pre>

<p>do-something
{% endraw %}
{% endhighlight %}</p>

<p>多亏STL接口的一致性，这让我们写出了很多“一致性“代码。慢慢地我觉得恶心，不禁想起函数式编程语言中，对于这种需求一般都会提供类似的接口：</p>

<p>{% highlight lua %}
con.map(function (it) if (it->some-filed == some-value) return something end)</p>

<h1>或者</h1>

<p>con.each do |it| if it.some-filed == some-value then return something end end</p>

<h1>或者</h1>

<p>(con.map (lambda (it) (if ((= it.some-filed some-value)) (return something))))
{% endhighlight %}</p>

<p>（好吧，lisp我又忘了）总之，这种针对容器的遍历操作，都会成为一种内置接口，并且通过lambda来让用户直接编写处理代码，少去写循环的冗余。然后，我写了类似下面的一组宏（随手敲的不保证能运行）：</p>

<p>{% highlight c++ %}
{% raw %}</p>

<h1>define IT_N __it</h1>

<h1>define TRAVERSE_MAP(type, map, exps) \</h1>

<pre><code>for (type::iterator IT_N = map.begin(); IT_N != map.end(); ++IT_N) { \
    exps; \
}
</code></pre>

<h1>define I_KEY (IT_N->first)</h1>

<h1>define I_VALUE (IT_N->second)</h1>

<h1>define TRAVERSE_LIST(type, list, exps) \</h1>

<pre><code>for (type::iterator IT_N = list.begin(); IT_N != list.end(); ++IT_N) { \
    exps; \
}
</code></pre>

<h1>define L_VALUE (*IT_N)</h1>

<h1>define FIND_MAP_ITEM(type, map, key, fexps, texps) \</h1>

<pre><code>do { \
    type::iterator IT_N = map.find(key); \
    if (IT_N == map.end()) { \
        fexps; \
    } else { \
        texps; \
    } \
} while(0)
</code></pre>

<h1>define VAL_N __val</h1>

<h1>define FIND_LIST_ITEM_IF(type, list, cmp, fexps, texps) \</h1>

<pre><code>do { \
    struct Comp { \
        bool operator() (const type::value_type &amp;VAL_N) const { \
            return cmp; \
        } \
    }; \
    type::iterator IT_N = std::find_if(list.begin(), list.end(), Comp()); \
    if (IT_N != list.end()) { \
        texps; \
    } else { \
        fexps; \
    } \
} while(0)
</code></pre>

<h1>define NULL_EXP ;</h1>

<p>{% endraw %}
{% endhighlight %}</p>

<p>当然，以上接口都还包含一些const版本，用于const容器的使用。使用的时候（截取的项目中的使用例子）：</p>

<p>{% highlight c++ %}
TRAVERSE_MAP(TimerTable, m_timers,</p>

<pre><code>    I_VALUE.obj-&gt;OnTimerCancel(I_KEY, I_VALUE.arg);
    TIMER_CANCEL(I_VALUE.id)); 
</code></pre>

<p>TRAVERSE_LIST(AreaList, areas,</p>

<pre><code>    ids.push_back(L_VALUE-&gt;ID()));
</code></pre>

<p>FIND_MAP_ITEM(PropertyTable, m_properties, name,</p>

<pre><code>    LogWarn("set a non-existed property %s", name.c_str()); return NIL_VALUE,
    if (val.Type() != I_VALUE.type()) {
        return NIL_VALUE; 
    } else {
        GValue old = I_VALUE;
        I_VALUE = val; 
        return old;
    });
</code></pre>

<p>{% endhighlight %}</p>

<p>多亏了C/C++宏对一切内容的可容纳性，可以让我往宏参数里塞进像if这种复合语句，甚至多条语句（例如最后一个例子）。这些宏我使用了一段时间，开始觉得挺爽，很多函数的实现里，我再也不用写那些重复的代码了。但是后来我发觉这些代码越来越恶心了。最大的弊端在于不可调试，我只能将断点下到更深的代码层；然后就是看起来特不直观，连作者自己都看得觉得不直观了，可想而知那些连函数式编程语言都不知道是什么的C++程序员看到这些代码会是什么心情（可以想象哥已经被诅咒了多少次）。</p>

<p>函数式语言让人写出更短的代码，这一点也对我有影响，例如我最近又写下了一些邪恶代码：</p>

<p>{% highlight c++ %}
// split a string into several sub strings by a split character i.e:
// "a;b;c;" => "a", "b", "c"
// "a;b;c" => "a", "b", "c"
std::vector&lt;std::string> SplitString(const std::string &amp;str, char split) {</p>

<pre><code>std::vector&lt;std::string&gt; ret;
size_t last = 0;
for (size_t pos = str.find(split); pos != std::string::npos; last = pos + 1, pos = str.find(split, last)) {
    ret.push_back(str.substr(last, pos - last));
}
return last &lt; str.length() ? ret.push_back(str.substr(last)) : 0, ret;
</code></pre>

<p>}
{% endhighlight %}</p>

<p>恶心的就是最后那条return语句，因为我需要处理"a;b;c"这种c后面没加分隔符的情况，但我并不愿意为了这个需求再写一个会占超过一行的if语句。因为，我太喜欢ruby里的if了：</p>

<p>{% highlight ruby %}
do-something if exp
{% endhighlight %}</p>

<p>也就是ruby里允许这种只有一行if的代码将if放在其后并作为一条语句。我的不愿意其实是有理由的，在c/c++中有太多只有一行条件体的if语句，对这些语句参合进编程风格/可读性进来后，就不得不让你写出不安的代码，例如：</p>

<p>{% highlight c++ %}
if (something) return something; // 某些编程风格里不允许这样做，因为它不方便调试</p>

<p>if (something)</p>

<pre><code>return something; // 某些风格里又有大括号的统一要求
</code></pre>

<p>if (something) {</p>

<pre><code>return something; // 就算符合风格了，但这一条语句就得多个大括号
</code></pre>

<p>}</p>

<p>if (something)
{</p>

<pre><code>return something; // 某些风格里这大括号就更奢侈了
</code></pre>

<p>}
{% endhighlight %}</p>

<p>这个return除了乍看上去有点纠结外，其实也不算什么大问题，但是那个问号表达式返回的0实在没有任何意义，而正是没有意义才会让它误导人。本来我是可以写成：</p>

<p>{% highlight c++ %}
return last &lt; str.length() &amp;&amp; ret.push_back(str.substr(last)), ret;
{% endhighlight %}</p>

<p>这样利用条件表达式的短路运算，代码也清晰多了。但是，std::vector::push_back是一个没有返回值的函数，所以。</p>

<p>全文完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为octopress每篇文章添加一个文章信息]]></title>
    <link href="http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/"/>
    <updated>2012-07-26T14:27:00+08:00</updated>
    <id>http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress</id>
    <content type="html"><![CDATA[<p>当你的博客文章被转载时，你肯定希望转载者能添加一个原始地址。或者你的文章被各种RSS抓取器抓取时，你也希望能在明显的位置显示这个原始地址。使用octopress写博客时，可以通过插件来做这件事。最开始，我只是想单纯地添加这个“原始地址“，一番google未能找到现成的插件，所以只好动手。</p>

<p>话说编写octopress真不是件容易事，因为我实在没找到编写插件的文档。octopress基于jekyll，jekyll又使用了liquid。最后我把这几个项目的文档都翻了下，也仅仅看到几个代码示例，而且liquid的API页面居然出错。无奈之下只好多翻了些现有插件的代码，摸索着来写。写octopress的插件，主要分为generator/tag/filter几种。tag很好理解，就是在文章中插入一个插件注册的tag，然后生成页面时就会调用到对应的插件。filter大概就是把文章内容过滤一遍转换成其他内容输出。</p>

<!-- more -->


<p>后来发现了一篇文章<a href="http://xoyo.name/2012/04/auto-spacing-for-octopress/">&lt;给中英文间加个空格></a>，这人写的插件从流程上大致是我需要的，模仿如下：</p>

<p>{% highlight ruby %}
{% raw %}
#</p>

<h1>post_footer_filter.rb</h1>

<h1>Append every post some footer infomation like original url</h1>

<h1>Kevin Lynx</h1>

<h1>7.26.2012</h1>

<p>#
require './plugins/post_filters'</p>

<p>module AppendFooterFilter
  def append(post)</p>

<pre><code> author = post.site.config['author']
 url = post.site.config['url']
 pre = post.site.config['original_url_pre']
 post.content + %Q[&lt;p class='post-footer'&gt;
        #{pre or "original link:"}
        &lt;a href='#{post.full_url}'&gt;#{post.full_url}&lt;/a&gt;&lt;br/&gt;
        &amp;nbsp;written by &lt;a href='#{url}'&gt;#{author}&lt;/a&gt;
        &amp;nbsp;posted at &lt;a href='#{url}'&gt;#{url}&lt;/a&gt;
        &lt;/p&gt;]
</code></pre>

<p>  end
end</p>

<p>module Jekyll
  class AppendFooter &lt; PostFilter</p>

<pre><code>include AppendFooterFilter
def pre_render(post)
  post.content = append(post) if post.is_post?
end
</code></pre>

<p>  end
end</p>

<p>Liquid::Template.register_filter AppendFooterFilter
{% endraw %}
{% endhighlight %}</p>

<p>大概就是当传入的页面是post时，就添加页脚信息，我这里主要添加了原始地址和作者信息，并且留了个post-footer作为这个段落的样式定制。附加的信息对于RSS输出同样有效。</p>

<p>这个插件的使用方式很简单，直接放到plugins目录下即可。可以在_config.yml中配置下origional_url_pre，例如配置为“原始地址：“。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ruby中的case...when语法]]></title>
    <link href="http://codemacro.com/2012/07/26/ruby-case-when/"/>
    <updated>2012-07-26T10:13:00+08:00</updated>
    <id>http://codemacro.com/2012/07/26/ruby-case-when</id>
    <content type="html"><![CDATA[<p>参考<a href="http://stackoverflow.com/questions/948135/how-to-write-a-switch-statement-in-ruby">How to write a switch statement in Ruby?</a></p>

<p>其实用Rails写个业务逻辑不算复杂的app根本用不上ruby的很多高级语法，更别说&lt;meta programming in ruby>中的东西了（凡是打上meta programming标签的都不是什么简单的东西，参考c++/lisp）。ruby中的case...when语句和c/c++中的switch...case其实根本不是一回事。&lt;Programming in Ruby 2nd>：</p>

<blockquote><p>case operates by comparing the target with each of the comparison expression after the when keywords. This test is done using comparison === target.</p></blockquote>

<!-- more -->


<p>也就是说case...when用的不是==操作符，不是使用相等逻辑去判断，而是使用===运算符。===运算符从C++的角度简单来说就是判定is-a关系，例如</p>

<p>{% highlight ruby %}
Fixnum === 1
String === "hello"
(1..3) === 2
{% endhighlight %}</p>

<p>1 is a Fixnum，hello is a String，2 is a (1..3) (in the range of)。比较让人产生误解的，大概就是1===1也为true。所以理解起来，也不纯碎是is-a关系。</p>

<p>{% highlight ruby %}
case a
when Fixnum</p>

<pre><code>puts "fixnum"
</code></pre>

<p>when String</p>

<pre><code>puts "string"
</code></pre>

<p>when (1..3)</p>

<pre><code>puts "between 1 and 3"
</code></pre>

<p>else</p>

<pre><code>puts "default"
</code></pre>

<p>end
{% endhighlight %}</p>

<p>最后，作为一种functional-like language，其语句也算是表达式，意即也有返回值。case..when的返回值就是执行的分支的返回值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTML中table的高亮以及tooltip]]></title>
    <link href="http://codemacro.com/2012/07/24/html-table-hover/"/>
    <updated>2012-07-24T16:08:00+08:00</updated>
    <id>http://codemacro.com/2012/07/24/html-table-hover</id>
    <content type="html"><![CDATA[<p>在一个需要显示很多数据的表格(table)中，为了更友好地查看一行数据，常常需要在鼠标指针移到某一行时，高亮此行。要实现这个效果有很多方法，这里列举一个方法：</p>

<p>{% highlight javascript %}
{% raw %}
function setTableHover(t) {
  $(t + " tbody tr")</p>

<pre><code>  .mouseover(function() { $(this).addClass("hover");})
  .mouseout(function() { $(this).removeClass("hover"); })
</code></pre>

<p>}
{% endraw %}
{% endhighlight %}</p>

<p>主要就是在鼠标移到某一行时，为该行添加一个高亮的css class，鼠标离开时移除该class即可。可以为一个特定的table设定：</p>

<!-- more -->


<p>{% highlight html %}
{% raw %}</p>

<table id="test">
</table>


<script>
    setTableHover('#test')
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<p>甚至可以为将某个页面的所有table设为高亮：</p>

<p>{% highlight html %}
{% raw %}</p>

<script>
    setTableHover('table')
</script>


<p>{% endraw %}
{% endhighlight %}</p>

<p>css里需要编写这个hover：</p>

<p>{% highlight css %}
{% raw %}
.hover {
  background: #e9cffa;
}
{% endraw %}
{% endhighlight %}</p>

<hr/>


<p>除了高亮显示某一行外，可能还需要在鼠标移动到某个单元格时，弹出一个tooltip。这里的tooltip可以是<a href="http://codemacro.com/2012/07/19/popup-window-in-html/">弹出窗口</a>，也就是一个div元素。</p>

<p>{% highlight html %}
{% raw %}
<tr>
  <td class="tip"></p>

<pre><code>hello
&lt;div class='popup' style='display:none;'&gt;this is the tip&lt;/div&gt;
</code></pre>

<p>  </td>
</tr>
{% endraw %}
{% endhighlight %}</p>

<p>要实现此效果，可以通过修改包含tip class的鼠标事件响应：</p>

<p>{% highlight javascript %}
{% raw %}
$(function () {</p>

<pre><code>$('.tip').hover(
    function () {
        show_popupex($(this).find("div"), $(this));
    },
    function () {
        $(this).find("div").hide();
    }
    );
</code></pre>

<p>});
{% endraw %}
{% endhighlight %}</p>

<p>hover的第一个参数表示鼠标进入的响应，第二个参数表示鼠标离开的响应。show_popupex用于将一个元素以绝对位置显示在指定元素（这里是单元格）附近，可以参看<a href="http://codemacro.com/2012/07/19/popup-window-in-html/">弹出窗口</a>那篇文章。</p>
]]></content>
  </entry>
  
</feed>
