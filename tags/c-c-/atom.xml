<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: c/c++ | loop in codes]]></title>
  <link href="http://codemacro.com/tags/c-c-/atom.xml" rel="self"/>
  <link href="http://codemacro.com/"/>
  <updated>2012-07-31T09:43:48+08:00</updated>
  <id>http://codemacro.com/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[像写函数式语言代码一样写C++]]></title>
    <link href="http://codemacro.com/2012/07/30/write-cpp-like-fp/"/>
    <updated>2012-07-30T17:11:00+08:00</updated>
    <id>http://codemacro.com/2012/07/30/write-cpp-like-fp</id>
    <content type="html"><![CDATA[<p>忘记最早接触函数式编程语言是什么时候了，也忘记接触的第一门函数式语言是哪一门。断断续续接触过好几种函数式语言（当然都算不纯的，ruby/lisp不算纯吧），这些语言的思想在潜移默化中多多少少对我有所影响。</p>

<p>我是个C++程序员，我不知道我平时写的都是些什么代码。最让人印象深刻就是我会经常写遍历STL容器的代码，是经常，这样的遍历你可能也不陌生：</p>

<p>{% highlight c++ %}
{% raw %}
for (ListType::iterator it = con.begin(); it != con.end(); ++it) {</p>

<pre><code>something
</code></pre>

<p>}
{% endraw %}
{% endhighlight %}</p>

<!-- more -->


<p>或者针对std::map/set等的查找：</p>

<p>{% highlight c++ %}
{% raw %}
Table::iterator it = table.find(key);
if (it == table.end())</p>

<pre><code>do-something
</code></pre>

<p>do-something
{% endraw %}
{% endhighlight %}</p>

<p>多亏STL接口的一致性，这让我们写出了很多“一致性“代码。慢慢地我觉得恶心，不禁想起函数式编程语言中，对于这种需求一般都会提供类似的接口：</p>

<p>{% highlight lua %}
con.map(function (it) if (it->some-filed == some-value) return something end)</p>

<h1>或者</h1>

<p>con.each do |it| if it.some-filed == some-value then return something end end</p>

<h1>或者</h1>

<p>(con.map (lambda (it) (if ((= it.some-filed some-value)) (return something))))
{% endhighlight %}</p>

<p>（好吧，lisp我又忘了）总之，这种针对容器的遍历操作，都会成为一种内置接口，并且通过lambda来让用户直接编写处理代码，少去写循环的冗余。然后，我写了类似下面的一组宏（随手敲的不保证能运行）：</p>

<p>{% highlight c++ %}
{% raw %}</p>

<h1>define IT_N __it</h1>

<h1>define TRAVERSE_MAP(type, map, exps) \</h1>

<pre><code>for (type::iterator IT_N = map.begin(); IT_N != map.end(); ++IT_N) { \
    exps; \
}
</code></pre>

<h1>define I_KEY (IT_N->first)</h1>

<h1>define I_VALUE (IT_N->second)</h1>

<h1>define TRAVERSE_LIST(type, list, exps) \</h1>

<pre><code>for (type::iterator IT_N = list.begin(); IT_N != list.end(); ++IT_N) { \
    exps; \
}
</code></pre>

<h1>define L_VALUE (*IT_N)</h1>

<h1>define FIDN_MAP_ITEM(type, map, key, fexps, texps) \</h1>

<pre><code>do { \
    type::iterator IT_N = map.find(key); \
    if (IT_N == map.end()) { \
        fexps; \
    } else { \
        texps; \
    } \
} while(0)
</code></pre>

<h1>define VAL_N __val</h1>

<h1>define FIND_LIST_ITEM_IF(type, list, cmp, fexps, texps) \</h1>

<pre><code>do { \
    struct Comp { \
        bool operator() (const type::value_type &amp;VAL_N) const { \
            return cmp; \
        } \
    }; \
    type::iterator IT_N = std::find_if(list.begin(), list.end(), Comp()); \
    if (IT_N != list.end()) { \
        texps; \
    } else { \
        fexps; \
    } \
} while(0)
</code></pre>

<h1>define NULL_EXP ;</h1>

<p>{% endraw %}
{% endhighlight %}</p>

<p>当然，以上接口都还包含一些const版本，用于const容器的使用。使用的时候（截取的项目中的使用例子）：</p>

<p>{% highlight c++ %}
TRAVERSE_MAP(TimerTable, m_timers,</p>

<pre><code>    I_VALUE.obj-&gt;OnTimerCancel(I_KEY, I_VALUE.arg);
    TIMER_CANCEL(I_VALUE.id)); 
</code></pre>

<p>TRAVERSE_LIST(AreaList, areas,</p>

<pre><code>    ids.push_back(L_VALUE-&gt;ID()));
</code></pre>

<p>FIND_MAP_ITEM(PropertyTable, m_properties, name,</p>

<pre><code>    LogWarn("set a non-existed property %s", name.c_str()); return NIL_VALUE,
    if (val.Type() != I_VALUE.type()) {
        return NIL_VALUE; 
    } else {
        GValue old = I_VALUE;
        I_VALUE = val; 
        return old;
    });
</code></pre>

<p>{% endhighlight %}</p>

<p>多亏了C/C++宏对一切内容的可容纳性，可以让我往宏参数里塞进像if这种复合语句，甚至多条语句（例如最后一个例子）。这些宏我使用了一段时间，开始觉得挺爽，很多函数的实现里，我再也不用写那些重复的代码了。但是后来我发觉这些代码越来越恶心了。最大的弊端在于不可调试，我只能将断点下到更深的代码层；然后就是看起来特不直观，连作者自己都看得觉得不直观了，可想而知那些连函数式编程语言都不知道是什么的C++程序员看到这些代码会是什么心情（可以想象哥已经被诅咒了多少次）。</p>

<p>函数式语言让人写出更短的代码，这一点也对我有影响，例如我最近又写下了一些邪恶代码：</p>

<p>{% highlight c++ %}
// split a string into several sub strings by a split character i.e:
// "a;b;c;" => "a", "b", "c"
// "a;b;c" => "a", "b", "c"
std::vector&lt;std::string> SplitString(const std::string &amp;str, char split) {</p>

<pre><code>std::vector&lt;std::string&gt; ret;
size_t last = 0;
for (size_t pos = str.find(split); pos != std::string::npos; last = pos + 1, pos = str.find(split, last)) {
    ret.push_back(str.substr(last, pos - last));
}
return last &lt; str.length() ? ret.push_back(str.substr(last)) : 0, ret;
</code></pre>

<p>}
{% endhighlight %}</p>

<p>恶心的就是最后那条return语句，因为我需要处理"a;b;c"这种c后面没加分隔符的情况，但我并不愿意为了这个需求再写一个会占超过一行的if语句。因为，我太喜欢ruby里的if了：</p>

<p>{% highlight ruby %}
do-something if exp
{% endhighlight %}</p>

<p>也就是ruby里允许这种只有一行if的代码将if放在其后并作为一条语句。我的不愿意其实是有理由的，在c/c++中有太多只有一行条件体的if语句，对这些语句参合进编程风格/可读性进来后，就不得不让你写出不安的代码，例如：</p>

<p>{% highlight c++ %}
if (something) return something; // 某些编程风格里不允许这样做，因为它不方便调试</p>

<p>if (something)</p>

<pre><code>return something; // 某些风格里又有大括号的统一要求
</code></pre>

<p>if (something) {</p>

<pre><code>return something; // 就算符合风格了，但这一条语句就得多个大括号
</code></pre>

<p>}</p>

<p>if (something)
{</p>

<pre><code>return something; // 某些风格里这大括号就更奢侈了
</code></pre>

<p>}
{% endhighlight %}</p>

<p>这个return除了乍看上去有点纠结外，其实也不算什么大问题，但是那个问号表达式返回的0实在没有任何意义，而正是没有意义才会让它误导人。本来我是可以写成：</p>

<p>{% highlight c++ %}
return last &lt; str.length() &amp;&amp; ret.push_back(str.substr(last)), ret;
{% endhighlight %}</p>

<p>这样利用条件表达式的短路运算，代码也清晰多了。但是，std::vector::push_back是一个没有返回值的函数，所以。</p>

<p>全文完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多重继承和void*的糗事]]></title>
    <link href="http://codemacro.com/2011/04/30/multi-inherit-void/"/>
    <updated>2011-04-30T00:00:00+08:00</updated>
    <id>http://codemacro.com/2011/04/30/multi-inherit-void</id>
    <content type="html"><![CDATA[<p>C++为了兼容C，导致了不少语言阴暗面。Bjarne
Stroustrup在&lt;D&amp;E>一书里也常为此表现出无奈。另一方面，强制转换也是C++的一大诟病。但是，因为我们的应用环境总是那么“不
纯”，所以也就常常导致各种问题。</p>

<p>本文即描述了一个关于强制转换带来的问题。这个问题几年前我曾遇到过(&lt;<a href="http://www.cppblog.com/kevinlynx/archive/2008/04/24/48001.html">多线程下vc2003,vc2005对虚函数表处理的BUG？</a>>)，当时没来得及深究。深究C++的某些语法，实在是件辛苦事。所以，这里也不提过于诡异的用法。</p>

<!-- more -->


<h2>问题</h2>

<p>考虑下面非常普通的多重继承代码:</p>

<p>{% highlight c++ %}
class Left {
public:</p>

<pre><code>virtual void ldisplay () {
    printf ("Left::ldisplay\n");
}
</code></pre>

<p>};</p>

<p>class Right {
public:</p>

<pre><code>virtual void rdisplay () {
    printf ("Right::rdisplay\n");
}
</code></pre>

<p>};</p>

<p>class Bottom : public Left, public Right {
public:</p>

<pre><code>virtual void ldisplay () {
    printf ("Bottom::ldisplay\n");
}
</code></pre>

<p>};</p>

<p>{% endhighlight %}
这样子的代码在我们的项目中很容易就会出现，例如:</p>

<p>{% highlight c++ %}
class BaseObject;
class EventListener;
class Player : public BaseObject, public EventListener
{% endhighlight %}</p>

<p>别紧张，我当然不会告诉你这样的代码是有安全隐患的。但它们确实在某些时候会出现隐患。在我们的C++项目中，也极有可能会与一些纯C模块打交道。在C语言里，极有肯能出现以
下的代码:</p>

<p>{% highlight c++ %}
typedef void (<em>allocator) (void </em>u);
void set_allocator (allocator alloc, void *u);
{% endhighlight %}</p>

<p>之所以使用回调函数，是出于对模块的通用性的考虑。而在调用回调函数时，也通常会预留一个user
data的指针，用于让应用层自由地传递数据。</p>

<p>以上关于多重继承和void*的使用中，都属于很常规的用法。但是当它们遇到一起时，事情就悲剧了。考虑下面的代码:</p>

<p>{% highlight c++ %}
Bottom <em>bobj = new Bottom(); // we HAVE a bottom object
Right </em>robj = bobj; // robj point to bobj?
robj->rdisplay(); // display what ?
void <em>vobj = bobj; // we have a VOID</em> pointer
robj = (Right*) vobj; // convert it back
robj->rdisplay(); // display what?
{% endhighlight %}</p>

<p>这里的输出结果是什么呢？:</p>

<p>{% highlight c++ %}
Right::rdisplay
Bottom::ldisplay // !!!!
{% endhighlight %}</p>

<p>由void*转回来的robj调用rdisplay时，却调用了莫名其妙的Bottom::ldisplay！</p>

<h2>多重继承类的内存布局</h2>

<p>类对象的内存布局，并不属于C++标准。这里仅以vs2005为例。上面例子中，Bottom类的内存布局大概如下:</p>

<pre><code>+-------------+
| Left_vptr   |
+-------------+
| Left data   |
+-------------+
| Right_vptr  |
+-------------+
| Right data  |
+-------------+
| Bottom data |
+-------------+
</code></pre>

<p>与单继承不同的是，多重继承的类里，可能会包含多个vptr。当一个Bottom对象被构造好时，其内部的两个vptr也被正确初始化，其指向的vtable分别为:</p>

<pre><code>Left_vptr ---&gt;  +---------------------+
                | 0: Bottom::ldisplay |
                +---------------------+

Right_vptr ---&gt; +---------------------+
                | 0: Right::rdisplay  |
                +---------------------+
</code></pre>

<h2>转换的内幕</h2>

<p><strong>类体系间的转换</strong></p>

<p>隐式转换相比强制转换而言，一定算是优美的代码。考虑如下代码的输出:</p>

<p>{% highlight c++ %}
Bottom <em>bobj = new Bottom();
printf ("%p\n", bobj);
Right </em>robj = bobj;
printf ("%p\n", robj);
{% endhighlight %}</p>

<p>其输出结果可能为:</p>

<pre><code>003B5DA0
003B5DA4
</code></pre>

<p><em><em>结论就是，Right</em>robj = bobj;时，编译器返回了bobj的一个偏移地址。</em>*
从语言角度看，就是这个转换，返回了bobj中Right*的那一部分的起始地址。但编译器并不总是在bobj上加一个偏移，例如:</p>

<pre><code>bobj = NULL;
Right *robj = bobj;
</code></pre>

<p>编译器不会傻到给你一个0x00000004的地址，这简直比NULL更无理。</p>

<p><em><em>void</em>转换</em>*</p>

<p>编译器当然有理由做上面的偏移转换。那是因为在编译阶段，编译器就知道bobj和Right之间的关系。这个偏移量甚至不需要在运行期间动态计算，或是从某个地方取。如果你看过上面代码对应的汇编指令，直接就是:</p>

<pre><code>add eax, 4 ; 直接加 sizeof(Left)，记住，Right在Left之后
</code></pre>

<p>void<em>就没那么幸运了。void</em>和Bottom没有任何关系，所以:</p>

<pre><code>void *vobj = bobj; // vobj的地址和bobj完全相同
</code></pre>

<p>然后当你将vobj转换到一个Right*使用时:</p>

<pre><code>robj = (Right*) vobj;  // 没有偏移转换，robj == vobj == bobj
robj-&gt;rdisplay();
</code></pre>

<p>robj指向的是Bottom的起始地址，天啊，在我们学习C++时，我们可以说Bottom就是一个Left，也是一个Right，所谓的is
kind of。但这里的悲剧在于，按照上面的逻辑，我们在使用Right时，其实应该使用Bottom里Right那一部分。
<strong>但现在这个转换，却让robj指向了Bottom里Left那一部分。</strong></p>

<p>当调用 <code>robj-&gt;rdisplay</code> 时，编译器当然按照Right的内存布局，生成一个虚函数的调用指令，大概就是:</p>

<pre><code>mov vptr, robj-&gt;[0] ;; vptr在robj起始地址处
mov eax, vptr[0] ;; rdisplay在vtable中位于第一个
mov ecx, robj
call eax
</code></pre>

<p>总而言之， <code>robj-&gt;rdisplay</code>
就是使用偏移0处的值作为vptr，然后使用vptr指向的vtable中第一个函数作为调用。</p>

<p>但，robj正指向bobj的起始地址，这个地址是放置Left_vptr的地方。这个过程，使用了Left_ptr，而Left_ptr指向的vtable中，第一个函数是什么呢？:</p>

<pre><code>Left_vptr ---&gt;  +---------------------+
                | 0: Bottom::ldisplay |
                +---------------------+
</code></pre>

<p>正是Bottom::ldisplay！到这里，整个问题的原因就被梳理出来了。</p>

<p>;;END;;</p>
]]></content>
  </entry>
  
</feed>
