
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>loop in codes</title>
  <meta name="author" content="Kevin Lynx">

  
  <meta name="description" content="问题 在Lua中，因为函数也是第一类值，所以会出现将函数作为另一个函数的参数，或者函数作
为函数的返回值。这种机制在很多地方都能代码更灵活更简洁，例如: table.sort(table [,comp]) 这里的comp就要求传入一个函数，我们在调用时，大概会有如下形式: table.sort(t &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://kevinlynx.github.com/codemacro/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="loop in codes" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">loop in codes</a></h1>
  
    <h2>Kevin Lynx BLOG</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:kevinlynx.github.com/codemacro" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/05/09/lua-function-arg/">传递Lua函数到C/C++中</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-05-09T00:00:00+08:00" pubdate data-updated="true">May 9<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>问题</h2>

<p>在Lua中，因为函数也是第一类值，所以会出现将函数作为另一个函数的参数，或者函数作
为函数的返回值。这种机制在很多地方都能代码更灵活更简洁，例如:</p>

<div class="highlight"><pre><code class="lua">    <span class="nb">table.sort</span><span class="p">(</span><span class="n">table</span> <span class="p">[,</span><span class="n">comp</span><span class="p">])</span>
</code></pre>
</div>


<p>这里的comp就要求传入一个函数，我们在调用时，大概会有如下形式:</p>

<div class="highlight"><pre><code class="lua">    <span class="nb">table.sort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">comp</span><span class="p">)</span> <span class="c1">-- 直接写函数名</span>
    <span class="nb">table.sort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">local_comp</span><span class="p">)</span> <span class="c1">-- 某个局部函数</span>
    <span class="nb">table.sort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">xxx</span> <span class="k">end</span> <span class="p">)</span> <span class="c1">-- 临时构造一个匿名函数</span>
</code></pre>
</div>


<p>其中最后一种方式最为灵活，任意时候在需要的时候构造一个匿名函数。这种在Lua自身的
环境中使用，自然没有问题。但是，当我们在C/C++中注册一些函数到Lua环境中，而这些 函数也需要使用函数参数的时候，问题就出来了。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/2011/05/09/lua-function-arg/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/05/02/entity-property/">MMO游戏对象属性设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-05-02T00:00:00+08:00" pubdate data-updated="true">May 2<span>nd</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一般的MMORPG中，游戏对象主要包括怪物和玩家。这两类对象在经过游戏性方面的不断“进化”后，其属性数量及与之相关的逻辑往往会变得很巨大。如何将这一块做得既不损失效率，又能保证结构的灵活、清晰、可维护？本文将提供一种简单的结构。</p>

<h2>原始结构</h2>

<p>最原始的结构，极有可能为这样:</p>

<pre><code>Player:     +---------------+
            | property-1    |
            +---------------+
            | property-2    |
            +---------------+
            |     ...       |
            +---------------+
            | operator-1    |
            +---------------+
            | operator-2    |
            +---------------+
            | ...           |
            +---------------+
</code></pre>

<p>也就是，一个对象为一个C++类，然后里面直接塞满了各种属性名，然后是针对这个属性的逻辑操作（函数）。其结果就是Player成为巨类。针对这个情况，一直以来我觉得可以使用一种简单的方法来拆分这个类。冠以官腔，称之为Entity-Component-based
Desgin。产生这种想法和我的个人技术积累有一定关系，见下文。</p>

<h2>Policy-based Design</h2>

<p>Policy-based Design，基于决策的设计。这个概念来源于<Modern C++
Design\>。虽然这本书讲述的是针对C++模板的使用及设计技巧。但这种思想依然被我潜意识般地用在其他地方。Policy大致来说就是一个小的组件(Component)。它努力不依赖于其他东西，它可能就是个简单的类，它拥有极少的数据结构，及针对这些数据的极少操作接口。举例而言，玩家MP的自动回复功能，就可封装为一个Policy。将许多Policy组合起来，就可完成一个复杂的功能。</p>

<p>这种思想还可指导很多程序结构方面的设计。例如在做功能的接口拆分时，就将每个函数设计得足够小，小到单纯地完成一个功能。一个功能的入口函数，就将之前实现的小函数全部组合起来，然后共同完成功能点。</p>

<p>当然，<Modern C++ Design\>里的Policy在表现形式上有所不同。但其核心思想相同，主要体现在 <strong>组合</strong>
特点上。</p>

<h2>Entity-Component-based Design</h2>

<p>Entity-Component-based
Design按照google到的文章，严格来说算是与OOP完全不同的软件设计方法。不过在这里它将按照我的意思重新被解释。</p>

<p>如果说Policy-based
Design极大可能地影响着我们平时的细节编码，那么Entity-Component则是直接对游戏对象的结构设计做直接的说明。
<strong>一个游戏对象就是一个Entity。</strong> Entity拥有很少的属性，也许仅包含一个全局标示的ID。
<strong>一个Component则是Entity的某个行为、或者说某个组成部分。</strong>
其实说白了，以玩家为例，一个玩家对象就是一个Entity，而一个MP的自动回复功能就可被包装为一个Component。这个Component可能包含若干与该功能相关的数据，例如回复时间间隔，每次的回复量等。我们往玩家对象这个Entity添加各种Component，也就是给玩家添加各种逻辑功能。</p>

<p>但是，Component之间可能会涉及到交互，玩家对象之外的模块可能也会与玩家内的某个Component交互。子功能点的拆分，不得不涉及到更多的胶水代码，这也算一种代价。</p>

<h2>游戏对象属性设计</h2>

<p>这份属性结构设计，基本就是参考了上面提到的设计思想。整个系统有如下组件:</p>

<pre><code>Entity:    +-------------------+
           | property-table    |
           +-------------------+
           | component-table   |
           +-------------------+

Property:  +-------------------+
           | observer-list     |
           +-------------------+ 

Component: +--------------------+
           | logic-related data |
           +--------------------+
           | logic-related func |
           +--------------------+
</code></pre>

<p>意即，所有Entity都包含一个属性表和组件表。这里的属性表并非硬编码的属性数据成员集合，而是一个key-value形式的表。Property包含一个观察者列表，其实就是一系列回调函数，但是这些观察者本质上也是组件，后面会提到。Component正如上文描述，仅包含Component本身实现的功能所需要的数据和函数。整个结构大致的代码如下:</p>

<pre><code>class Entity {
private:
    GUID id;
    std::map&lt;std::string, IComponent*&gt; components;
    std::map&lt;std::string, Property*&gt; properties;
};

class Property {
private:
    std::string name;
    Value val;
    std::vector&lt;IComponent*&gt; observers;
};

class IComponent {
public:
    virtual bool Operate (const Args &amp;args) { return false; }
    virtual void OnNotify (const Property &amp;property, const Args &amp;args) {}
protected:
    std::string name;
    Entity *entity;
};
</code></pre>

<p>属性本身是抽象的，这完全是因为我们将属性统一地放在了一个表里。从而又导致属性的值也需要做一个抽象包装。</p>

<p>因为Component主要是针对游戏对象属性而存在的。而针对游戏对象属性的操作，我将其分为主动操作和被动操作，其对应的组件就被称为主动组件和被动组件。这里的主被动，主要是针对这个组件是通过哪种方式启动的。如果是某个地方直接需要某个组件启动，那么称为主动，例如玩家角色刚上线，需要编码角色属性到客户端，则启动属性更新组件；如果某个组件是因为某个属性的改变而启动，则称为被动，例如当玩家受到伤害，HP非满值时，则需要启动HP自动回复组件。</p>

<p>针对组件的主被动特性，就得到主动接口Operate，被动接口OnNotify。因为不同的组件实现，依赖的启动参数可能完全不一样，所以这里对参数做了Args的封装。Args具体实现时，可以采用类继承方式根据具体应用塞入具体的参数；也可以直接使用tuple来包装不同类型不同个数的参数。</p>

<p>因为有了个被动属性，所以就在属性身上放置了一个Observer列表。当然这里不一定要采用这种细粒度的方式&#8212;将Observer绑在属性身上，而可以将observer列表放到Entity身上。接下来看一些具体的用例。</p>

<h3>具体用例</h3>

<p><strong>上线属性更新</strong></p>

<pre><code>// serialize player to client
// 取得ClientUpdater组件
IComponent *updater = entity-&gt;GetComponent ("ClientUpdater");
// 更新至client_socket客户端
updater-&gt;Operate (Args (client_socket));
</code></pre>

<p><strong>玩家属性改变</strong></p>

<pre><code>// hurt player
// 取得属性存取组件
IComponent *accessor = entity-&gt;GetComponent ("PropertyAccessor");
// 改变属性
accessor-&gt;Operate (Args ("HP", Value(10))); // decrease 10 HP
...
// dirty property updator component get called
void DirtyUpdator::OnNotify (const Property &amp;property, const Args &amp;args) {
    // 将此属性放到脏属性容器，稍候统一更新
    dirties.push (property);
}
</code></pre>

<p>代码到真正应用时，可能会加入更多的接口，以下代码情景不追加叙述。</p>

<p><strong>游戏对象刚创建</strong></p>

<pre><code>// in script, or by config file, or hard code, etc...
entity-&gt;AddProperty ("HP", Args (10)) ;
entity-&gt;AddProperty ("MP", Args (5));
... 
entity-&gt;AddComponent (componentFactory-&gt;Create ("ClientUpdater"));
entity-&gt;AddComponent (componentFactory-&gt;Create ("PropertyAccessor"));
...
</code></pre>

<p><strong>组件被创建时</strong></p>

<pre><code>ClientUpdater::ClientUpdater () {
    entity-&gt;GetProperty ("HP")-&gt;AddObserver (this);
    ...
}
</code></pre>

<p>;;END;;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/04/30/multi-inherit-void/">多重继承和void*的糗事</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-30T00:00:00+08:00" pubdate data-updated="true">Apr 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>C++为了兼容C，导致了不少语言阴暗面。Bjarne
Stroustrup在&lt;D&amp;E>一书里也常为此表现出无奈。另一方面，强制转换也是C++的一大诟病。但是，因为我们的应用环境总是那么“不
纯”，所以也就常常导致各种问题。</p>

<p>本文即描述了一个关于强制转换带来的问题。这个问题几年前我曾遇到过(&lt;<a href="http://www.cppblog.com/kevinlynx/archive/2008/04/24/48001.html">多线程下vc2003,vc2005对虚函数表处理的BUG？</a>>)，当时没来得及深究。深究C++的某些语法，实在是件辛苦事。所以，这里也不提过于诡异的用法。</p>

<h2>问题</h2>

<p>考虑下面非常普通的多重继承代码:</p>

<div class="highlight"><pre><code class="c"><span class="n">class</span> <span class="n">Left</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ldisplay</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Left::ldisplay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">Right</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">rdisplay</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Right::rdisplay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">Bottom</span> <span class="o">:</span> <span class="n">public</span> <span class="n">Left</span><span class="p">,</span> <span class="n">public</span> <span class="n">Right</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">ldisplay</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Bottom::ldisplay</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>


<p>这样子的代码在我们的项目中很容易就会出现，例如:</p>

<div class="highlight"><pre><code class="c"><span class="n">class</span> <span class="n">BaseObject</span><span class="p">;</span>
<span class="n">class</span> <span class="n">EventListener</span><span class="p">;</span>
<span class="n">class</span> <span class="n">Player</span> <span class="o">:</span> <span class="n">public</span> <span class="n">BaseObject</span><span class="p">,</span> <span class="n">public</span> <span class="n">EventListener</span>
</code></pre>
</div>


<p>别紧张，我当然不会告诉你这样的代码是有安全隐患的。但它们确实在某些时候会出现隐患。在我们的C++项目中，也极有可能会与一些纯C模块打交道。在C语言里，极有肯能出现以
下的代码:</p>

<div class="highlight"><pre><code class="c"><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">allocator</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">u</span><span class="p">);</span> 
<span class="kt">void</span> <span class="n">set_allocator</span> <span class="p">(</span><span class="n">allocator</span> <span class="n">alloc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">u</span><span class="p">);</span>
</code></pre>
</div>


<p>之所以使用回调函数，是出于对模块的通用性的考虑。而在调用回调函数时，也通常会预留一个user
data的指针，用于让应用层自由地传递数据。</p>

<p>以上关于多重继承和void*的使用中，都属于很常规的用法。但是当它们遇到一起时，事情就悲剧了。考虑下面的代码:</p>

<div class="highlight"><pre><code class="c"><span class="n">Bottom</span> <span class="o">*</span><span class="n">bobj</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Bottom</span><span class="p">();</span> <span class="c1">// we HAVE a bottom object</span>
<span class="n">Right</span> <span class="o">*</span><span class="n">robj</span> <span class="o">=</span> <span class="n">bobj</span><span class="p">;</span> <span class="c1">// robj point to bobj?</span>
<span class="n">robj</span><span class="o">-&gt;</span><span class="n">rdisplay</span><span class="p">();</span> <span class="c1">// display what ?</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">vobj</span> <span class="o">=</span> <span class="n">bobj</span><span class="p">;</span> <span class="c1">// we have a VOID* pointer</span>
<span class="n">robj</span> <span class="o">=</span> <span class="p">(</span><span class="n">Right</span><span class="o">*</span><span class="p">)</span> <span class="n">vobj</span><span class="p">;</span> <span class="c1">// convert it back</span>
<span class="n">robj</span><span class="o">-&gt;</span><span class="n">rdisplay</span><span class="p">();</span> <span class="c1">// display what?</span>
</code></pre>
</div>


<p>这里的输出结果是什么呢？:</p>

<div class="highlight"><pre><code class="c"><span class="n">Right</span><span class="o">::</span><span class="n">rdisplay</span> 
<span class="n">Bottom</span><span class="o">::</span><span class="n">ldisplay</span> <span class="c1">// !!!!</span>
</code></pre>
</div>


<p>由void*转回来的robj调用rdisplay时，却调用了莫名其妙的Bottom::ldisplay！</p>

<h2>多重继承类的内存布局</h2>

<p>类对象的内存布局，并不属于C++标准。这里仅以vs2005为例。上面例子中，Bottom类的内存布局大概如下:</p>

<pre><code>+-------------+
| Left_vptr   |
+-------------+
| Left data   |
+-------------+
| Right_vptr  |
+-------------+
| Right data  |
+-------------+
| Bottom data |
+-------------+
</code></pre>

<p>与单继承不同的是，多重继承的类里，可能会包含多个vptr。当一个Bottom对象被构造好时，其内部的两个vptr也被正确初始化，其指向的vtable分别为:</p>

<pre><code>Left_vptr ---&gt;  +---------------------+
                | 0: Bottom::ldisplay |
                +---------------------+

Right_vptr ---&gt; +---------------------+
                | 0: Right::rdisplay  |
                +---------------------+
</code></pre>

<h2>转换的内幕</h2>

<p><strong>类体系间的转换</strong></p>

<p>隐式转换相比强制转换而言，一定算是优美的代码。考虑如下代码的输出:</p>

<div class="highlight"><pre><code class="c"><span class="n">Bottom</span> <span class="o">*</span><span class="n">bobj</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Bottom</span><span class="p">();</span>
<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bobj</span><span class="p">);</span>
<span class="n">Right</span> <span class="o">*</span><span class="n">robj</span> <span class="o">=</span> <span class="n">bobj</span><span class="p">;</span>
<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">robj</span><span class="p">);</span>
</code></pre>
</div>


<p>其输出结果可能为:</p>

<pre><code>003B5DA0
003B5DA4
</code></pre>

<p><em><em>结论就是，Right</em>robj = bobj;时，编译器返回了bobj的一个偏移地址。</em>*
从语言角度看，就是这个转换，返回了bobj中Right*的那一部分的起始地址。但编译器并不总是在bobj上加一个偏移，例如:</p>

<pre><code>bobj = NULL;
Right *robj = bobj;
</code></pre>

<p>编译器不会傻到给你一个0x00000004的地址，这简直比NULL更无理。</p>

<p><em><em>void</em>转换</em>*</p>

<p>编译器当然有理由做上面的偏移转换。那是因为在编译阶段，编译器就知道bobj和Right之间的关系。这个偏移量甚至不需要在运行期间动态计算，或是从某个地方取。如果你看过上面代码对应的汇编指令，直接就是:</p>

<pre><code>add eax, 4 ; 直接加 sizeof(Left)，记住，Right在Left之后
</code></pre>

<p>void<em>就没那么幸运了。void</em>和Bottom没有任何关系，所以:</p>

<pre><code>void *vobj = bobj; // vobj的地址和bobj完全相同
</code></pre>

<p>然后当你将vobj转换到一个Right*使用时:</p>

<pre><code>robj = (Right*) vobj;  // 没有偏移转换，robj == vobj == bobj
robj-&gt;rdisplay();
</code></pre>

<p>robj指向的是Bottom的起始地址，天啊，在我们学习C++时，我们可以说Bottom就是一个Left，也是一个Right，所谓的is
kind of。但这里的悲剧在于，按照上面的逻辑，我们在使用Right时，其实应该使用Bottom里Right那一部分。
<strong>但现在这个转换，却让robj指向了Bottom里Left那一部分。</strong></p>

<p>当调用 <code>robj-&gt;rdisplay</code> 时，编译器当然按照Right的内存布局，生成一个虚函数的调用指令，大概就是:</p>

<pre><code>mov vptr, robj-&gt;[0] ;; vptr在robj起始地址处
mov eax, vptr[0] ;; rdisplay在vtable中位于第一个
mov ecx, robj
call eax
</code></pre>

<p>总而言之， <code>robj-&gt;rdisplay</code>
就是使用偏移0处的值作为vptr，然后使用vptr指向的vtable中第一个函数作为调用。</p>

<p>但，robj正指向bobj的起始地址，这个地址是放置Left_vptr的地方。这个过程，使用了Left_ptr，而Left_ptr指向的vtable中，第一个函数是什么呢？:</p>

<pre><code>Left_vptr ---&gt;  +---------------------+
                | 0: Bottom::ldisplay |
                +---------------------+
</code></pre>

<p>正是Bottom::ldisplay！到这里，整个问题的原因就被梳理出来了。</p>

<p>;;END;;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/04/04/module-level/">浅谈代码分层：构建模块化程序</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-04T00:00:00+08:00" pubdate data-updated="true">Apr 4<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>模块化的程序是怎样的程序？我们可以说一个具有明显物理结构的软件是模块化的，例如带
插件的软件，一个完整的软件由若干运行时库共同构建；也可以说一个高度面向对象的库是
模块化的，例如图形引擎OGRE；也可以说一些具有明显层次结构的代码是模块化的。</p>

<p>模块化的软件具有很多显而易见的好处。在开发期，一个模块化的设计有利于程序员实现，
使其在实现过程中一直保持清晰的思路，减少潜伏的BUG；而在维护期，则有利于其他程序 员的理解。</p>

<p>在我看来，具有良好模块设计的代码，至少分为两种形式：</p>

<ul>
<li>整体设计没有层次之分，但也有独立的子模块，子模块彼此之间耦合甚少，这些子模块 构成了一个软件层，共同为上层应用提供服务；</li>
<li>整个库/软件拥有明显的层次之分，从最底层，与应用业务毫无相关的一层，到最顶层，
完全对应用进行直接实现的那一层，每一个相对高层的软件层依赖于更底层的软件层， 逐层构建。</li>
</ul>


<p>上述两种形式并非完全分离，在分层设计中，某一层软件层也可能由若干个独立的模块构成
。另一方面，这里也不会绝对说低层模块就完全不依赖于高层模块。这种双向依赖绝对不是 好的设计，但事实上我们本来就无法做出完美的设计。</p>

<p>本文将代码分层分为两大类：一是狭义上的分层，这种分层一般伴有文件形式上的表现；一 是广义上的分层，完全着眼于我们平时写的代码。</p>

<h2>软件分层</h2>

<p>软件分层一般我们可以在很多大型软件/库的结构图中看到。这些分层每一层本身就包含大
量代码。每个模块，每一个软件层都可能被实现为一个运行时库，或者其他以文件形式为 表现的东西。</p>

<h3>Example Android</h3>

<p>Android是Google推出的智能手机操作系统，在其官方文档中有Android的系统架构图：</p>

<p><img src="/assets/res/module_level/android-architecture.jpg" alt="image" /></p>

<p>这幅图中很好地反映了上文中提到的软件层次。整个系统从底层到高层分为Linux kernel，
Libraries/Runtime，Application
Framework，Applications。最底层的Kernel可以说与应
用完全不相关，直到最上层的Applications，才提供手机诸如联系人、打电话等应用功能。</p>

<p>每一层中，又可能分为若干相互独立（Again，没有绝对）的模块，例如Libraries那一层 中，就包含诸如Surface
manager/SGL等模块。它们可能都依赖于Kernel，并且提供接口给 上层，但彼此独立。</p>

<h3>Example Compiler</h3>

<p>在编译器实现中，也有非常明显的层次之分。这些层次可以完全按照编译原理理论来划分。 包括：</p>

<ul>
<li>词法分析：将文本代码拆分为一个一个合法的单词</li>
<li>语法分析：基于 <em>词法分析</em> 得到的单词流构建语法树</li>
<li>语义分析：基于 <em>语法分析</em> 得到的语法树进行语义上的检查等</li>
<li>生成器：基于 <em>语义分析</em> 结果（可能依然是语法树）生成中间代码</li>
<li>编译器：基于 <em>生成器</em> 得到的中间代码生成目标机器上的机器代码</li>
<li>链接器：基于 <em>编译器</em> 生成的目标代码链接成最终可执行程序</li>
</ul>


<p><strong>软件分层的好处之一就是对任务(task)的抽象，封装某个任务的实现细节，提供给其他 依赖模块更友好的使用接口。隔离带来的好处之一就是可轻易替换某个实现。</strong>
例如很 多UI库隔离了渲染器的实现，在实际使用过程中，既可以使用Direct X的渲染方式，也可 以使用OpenGL的实现方式。</p>

<p>但正如之前所强调，凡事没有绝对，凡事也不可过度。很多时候无法保证软件层之间就是单
向依赖。而另一些时候过度的分层也导致我们的程序过于松散，效率在粘合层之间绕来绕去 而消失殆尽。</p>

<h2>代码分层</h2>

<p>如果说软件分层是从大的方面讨论，那么本节说的代码分层，则是从小处入手。而这也更是
贴近我们日常工作的地方。本节讨论的代码分层，不像软件分层那样大。每一层可能就是 百来行代码，几个接口。</p>

<h3>Example C中的模块组织</h3>

<p>很多C代码写得少的C++程序员甚至对一个大型C程序中的模块组织毫无概念。这是对其他技 术接触少带来的视野狭窄的可怕结果。</p>

<p>在C语言的世界里，并不像某些C++教材中指出的那样，布满全局变量。当然全局变量的使
用也并不是糟糕设计的标志(goto不是魔鬼)。一个良好设计的C语言程序懂得如何去抽象、 封装模块/软件层。我们以Lua的源代码为例。</p>

<p>lua.h文件是暴露给Lua应用（Lua使用者）的直接信息源。接触过Lua的人都知道有个结构体
叫lua_State。但是lua.h中并没有暴露这个结构体的实现。因为一旦暴露了实现，使用者就
可能会随意使用其结构体成员，而这并不是库设计者所希望的。 <strong>封装数据的实现，也算 是构建模块化程序的一种方法。</strong></p>

<p>大家都知道暴露在头文件中的信息，则可能被当作该头文件所描述模块的接口描述。所以， 在C语言中任何置于头文件中的信息都需要慎重考虑。</p>

<p>相对的，我们可以在很多.c文件中看到很多static函数。例如lstate.c中的stack_init。
static用于限定其修饰对象的作用域，用它去修饰某个函数，旨在告诉：这个函数仅被当前文件（
模块）使用，它仅用于本模块实现所依赖，它不是提供给模块外的接口！
<strong>封装内部实现 ，暴露够用的接口，也是保持模块清晰的方式之一。</strong></p>

<p>良好的语言更懂得对程序员做一种良好设计的导向。但相对而言，C语言较缺乏这方面的语
言机制。在C语言中，良好的设计更依赖于程序员自己的功底。</p>

<h3>Example Java中的模块组织</h3>

<p>相较而言，Java语言则提供了模块化设计的语法机制。在Java中，如同大部分语言一样，一
般一个代码文件对应于一个代码模块。而在Java中，每个文件内只能有一个public class。 public
class作为该模块的对外接口。而在模块内部，则可能有很多其他辅助实现的class
，但它们无法被外部模块访问。这是语言提供的封装机制，一种对程序员的导向。</p>

<h3>Example OO语言中类接口设计</h3>

<p>无论在C++中，还是在Java中，一个类中的接口，都大致有各种访问权限。例如public、
private、protected。访问权限的加入旨在更精确地暴露模块接口，隐藏细节。</p>

<p>在C中较为缺乏类似的机制，但依然可以这样做。例如将结构体定义于.c文件中，将非 接口函数以static的方式实现于.c文件中。</p>

<p>OO语言中的这些访问权限关键字的应用尤为重要。C++新手们往往不知道哪些成员该public
，哪些该private。C++熟手们在不刨根挖底的情况下，甚至会对每个数据成员写出get/set
接口（那还不如直接public）。在public/private之间，我们需要做的唯一决策就是，哪些
数据/操作并非外部模块所需。如果外部模块不需要，甚至目前不需要，那么此刻，都不要
将其public。一个public信息少的class，往往是一个被使用者更喜欢的class。</p>

<p>（至于protected，则是用于继承体系之间，类之间的信息隐藏。）</p>

<h3>Example Lisp中的模块设计</h3>

<p>又得提提Lisp。</p>

<p>基于上文，我们发现了各种划分模块、划分代码层的方式，无论是语言提供，还是程序员自 己的应用。但是如何逐个地构建这些层次呢？</p>

<p>Lisp中倡导了一种更能体现这种将代码分层的方式：自底而上地构建代码。这个自底而上，
自然是按照软件层的高低之分而言。这个过程就像上文举的编译原理例子一样。我们先编写
词法分析模块，该模块可能仅暴露一个接口：get-token。然后可以立马对该模块进行功能
测试。然后再编写语法分析模块，该模块也可能只暴露一个接口：parse。语法分析模块建
立于词法分析模块之上。因为我们之前已经对词法分析模块进行过测试，所以对语法分析的 测试也可以立即进行。如此下去，直至构建出整个程序。</p>

<p>每一个代码层都会提供若干接口给上层模块。越上层的模块中，就更贴近于最终目标。每一
层都感觉是建立在新的“语言“之上。按照这种思想，最终我们就可以构建出DSL，即Domain Specific Language。</p>

<h3>分层的好处</h3>

<p>基于以上，我们可以总结很多代码分层的好处，它们包括（但不限于）：</p>

<ul>
<li>隐藏细节，提供抽象，隐藏的细节包括数据的表示（如lua_State）、功能的实现</li>
<li>在新的一层建立更高层的“语言”</li>
<li>接口清晰，修改维护方便</li>
<li>方便开发，将软件分为若干层次，逐层实现</li>
</ul>


<h3>一个问题的解决</h3>

<p>有时候，我们的软件层很难做到单向依赖。这可能是由于前期设计的失误导致，也可能确实
是情况所迫。在很多库代码中，也有现成的例子。一种解决方法就是通过回调。回调的实现
方式可以是回调函数、多态。多态的表现又可能是Listener等模式。</p>

<p>所有这些，主要是让底层模块不用知道高层模块。在代码层次上，它仅仅保存的是一个回调
信息，而这个信息具体是什么，则发生在运行期（话说以前给同事讲过这个）。这样就简单 避免了底层模块依赖高层模块的问题。</p>

<h2>END</h2>

<p>精确地定义一个软件中有哪些模块，哪些软件层。然后再精确地定义每个模块，每个头文件
，每个类中哪些信息是提供给外部模块的，哪些信息是私有的。这些过程是设计模块化程 序的重要方式。</p>

<p>但需要重新强调的是，过了某个度，那又是另一种形式的糟糕设计。但其中拿捏技巧，则只 能靠实践获取。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/03/30/lisp-rss/">Lisp实践：开发RSS阅读器</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-30T00:00:00+08:00" pubdate data-updated="true">Mar 30<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>一、RSS阅读器的实现</h1>

<p>RSS Reader的实现并不像它看上去那么复杂。当初在决定写这个作为Lisp练习时，甚至觉得
没有多少内容可做。其简单程度甚至用不了你启动一个慢速IDE的时间:D。对Lisp无兴趣的 TX只需要读完这一节即可，</p>

<h2>什么是RSS阅读器?</h2>

<p>RSS在实现上，可以说是XML的又一次扩张式的应用。因为RSS最重要的东西就是一个XML文件
。RSS主要用于Web中的内容同步。例如我们写的博客，门户网站的新闻，都是内容。Web服
务器将这些内容组织成XML，然后我们通过一个客户端来解析这些XML，就可以在不用直接访 问网站的情况下获取信息：
<img src="/assets/res/lisp_rss/rss-overview.png" alt="rss overview" /></p>

<p>RSS阅读器就是这样一个从Web服务器通过RSS（表现形式为XML）来获取信息内容的工具。它
可以被实现为一个独立的客户端程序，也可以实现为像Google Reader这种网页形式。后者
其核心功能其实是Google服务器在做，取得信息后再发给用户。</p>

<h2>RSS文件</h2>

<p>上已提及，RSS的实现其实就是个XML文件。这个XML文件格式非常简单，例如:</p>

<div class="highlight"><pre><code class="xml"><span class="cp">&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="nt">&lt;rss</span> <span class="na">version=</span><span class="s">&quot;2.0&quot;</span><span class="nt">&gt;</span>
   <span class="nt">&lt;channel&gt;</span>
      <span class="nt">&lt;title&gt;</span>Liftoff News<span class="nt">&lt;/title&gt;</span>
      <span class="nt">&lt;link&gt;</span>http://liftoff.msfc.nasa.gov/<span class="nt">&lt;/link&gt;</span>
      <span class="nt">&lt;description&gt;</span>Liftoff to Space Exploration.<span class="nt">&lt;/description&gt;</span>
      <span class="nt">&lt;item&gt;</span>
         <span class="nt">&lt;title&gt;</span>Star City<span class="nt">&lt;/title&gt;</span>
         <span class="nt">&lt;link&gt;</span>http://liftoff.msfc.nasa.gov/news/2003/news-starcity.asp<span class="nt">&lt;/link&gt;</span>
         <span class="nt">&lt;description&gt;</span>Oh no, you wrote another blog!<span class="nt">&lt;/description&gt;</span>
      <span class="nt">&lt;/item&gt;</span>
    <span class="nt">&lt;/channel&gt;</span>
<span class="nt">&lt;/rss&gt;</span>
</code></pre>
</div>


<p>我们身边到处都是RSS文件，例如
<a href="http://www.cppblog.com/rss.aspx">http://www.cppblog.com/rss.aspx</a>
。RSS文件的框架大 致为:</p>

<pre><code>&lt;rss&gt;
    &lt;channel&gt;
        &lt;item&gt;
        &lt;/item&gt;
        &lt;item&gt;
        &lt;/item&gt;
        ...
    &lt;/channel&gt;
&lt;/rss&gt;
</code></pre>

<p>对，其框架就是这样，一个channel节点，其下若干个item节点。举例来说，
<strong>CPPBLOG首页就 是一个channel，该channel下有若干原创文章，每篇文章就是一个item。</strong> 无论是channel
，还是item，都会有很多属性，例如title/description/link，有些属性是RSS规范里要求
必须有的，有的是可选的。</p>

<h2>交互过程</h2>

<p>那么，服务器和客户端是如何交互的呢？首先，服务器上的程序针对其某个页面，生成对应
的RSS文件。这个RSS文件基本上是有固定的URL的。客户端每次获取内容时，就从这个固定
的URL获取这个RSS文件。客户端获取到这个RSS文件后，解析之，再呈现给用户。这就是整
个过程。这个过程中客户端与服务器的交互，全部是正常的HTTP请求。</p>

<p>而RSS阅读器，如果做得足够简单，则只需要从指定的地方获取到RSS文件，然后解析这个 XML文件，然后以相对友好的形式显示即可。</p>

<h2>扩展</h2>

<p>虽然RSS阅读器在核心功能上很简单，但是作为一个可以使用的工具，依然有很多功能点需 要实现。基本功能包括：</p>

<ul>
<li>记录用户关注的RSS</li>
<li>缓存某个RSS过去一段时间更新的内容</li>
<li>对HTTP回应的处理，最重要的就是重定向处理</li>
</ul>


<p>我们还可以做很多扩展，例如Google Reader之类的在线RSS阅读器。这些阅读器的RSS抓取
功能做在服务器端，它们除了上面提到的基础功能外，还会包含内容分类，给内容打一些 标签，分析用户的订阅习惯然后推荐类似的内容等等。</p>

<h1>二、Lisp实现</h1>

<p>本节描述在Lisp中实现上文的内容。主要包括： <strong>通过HTTP请求获取到RSS文件、解析RSS文件 。</strong></p>

<h2>获取RSS文件</h2>

<p>Lisp虽然历史悠久，但其扩展库标准却做得很拙劣。偏应用级的扩展库要么由编译器实现提
供，要么就得自己在网上找。一方面使用者希望库使用起来方便，另一方面库开发者在跨编 译器实现方面也头疼不已。所幸现在有了quick
lisp，安装第三方库就像Ubuntu里安装软件 一样简单（大部分）。</p>

<p>socket支持就是面临的第一个问题。不过我这里并不考虑跨编译器实现的问题，直接使用 SBCL里的socket接口。</p>

<p>要获取RSS文件，只需要连接Web服务器，发起HTTP的GET请求即可。当然，建立TCP连接，组
建HTTP请求包，就不是这里的讨论了。我们还是拿CPPBLOG首页的RSS为例，该RSS的URL为:</p>

<pre><code>http://www.cppblog.com/rss.aspx
</code></pre>

<p>拆分一下，得到host为www.cppblog.com（即我们要connect的地址），rss的uri为
/rss.aspx（即HTTP请求里的文件URI），于是建立HTTP请求包:</p>

<pre><code>GET /rss.aspx HTTP/1.0
Host: www.cppblog.com
</code></pre>

<p>关于HTTP请求的一些基础知识，可以参考我很早前写的一篇博客：&lt;<a href="http://www.cppblog.com/kevinlynx/archive/2008/07/30/57521.aspx">实现自己的http服务器</a>>。
正常情况下，Web服务器就会返回RSS的文件内容。然后我们就可以继续解析。</p>

<h2>解析RSS</h2>

<p>RSS本身是一个XML格式的文件。之前连接Web服务器发起HTTP请求没有用到第三方库，但是
解析XML文件不是几十来行代码能搞定的事情，所以这里需要选用一个第三方库。</p>

<p>我用的是s-xml，这个库在我之前的
<a href="http://www.cppblog.com/kevinlynx/archive/2011/03/13/141713.aspx">关于Lisp的文章</a>
中提到过。s-xml与我之前在C++ 领域见到的XML解析库最大的不同点在于，它提供的API是基于事件模式的。意思是说，你不
要去查询某个element的值是多少，当我解析到的时候会告诉你。事件模式的编程方式自然 离不开回调函数:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">s-xml:start-parse-xml</span> 
  <span class="nc">stream</span>
  <span class="p">(</span><span class="nb">make-instance</span> <span class="ss">&#39;s-xml:xml-parser-state</span>
                 <span class="ss">:new-element-hook</span> <span class="nf">#&#39;</span><span class="nv">decode-rss-new-element</span>
                 <span class="ss">:finish-element-hook</span> <span class="nf">#&#39;</span><span class="nv">decode-rss-finish-element</span>
                 <span class="ss">:text-hook</span> <span class="nf">#&#39;</span><span class="nv">decode-rss-text</span><span class="p">)))</span>
</code></pre>
</div>


<p>与s-xml交互的也就是上面代码里提到的三个函数：new-element-hook, finish-element-hook ,
text-hook。这种类型的接口导致解析代码大量减少，但不利于理解。我们要在整个解析
过程中传递数据，需要通过与s-xml交互的函数参数（当然不会蠢到去用全局变量）。</p>

<p>解析过程中通过往函数参数指定的对象身上塞数据完成，整个解析实现也就几十行代码。 文章尾可下载代码看看。</p>

<h2>显示出来</h2>

<p>通过上面两步，我们得到了RSS文件、解析出了具体内容，最后一步就是呈现出来看看。RSS
文件里每个Item都是一篇文章（新闻之类），这个文章内容可直接包含HTML标记，说白了，
这些内容就是直接的HTML内容。要显示这些内容，最简单的方法就是把一个RSS转换成一种 简单的HTML文件，以供阅读。</p>

<p>这里就涉及到HTML generator，几乎所有的Lisper都会写一个HTML产生器（库）（虽然目前
我还没写）。这种库的作用就是方便地输出HTML文件。</p>

<p>Lisp相对于其他语言很大的一个特点，或者说是优点，就是其语言本身的扩展能力。这种扩
展不是简单的添加几个函数，也不是类，而是提供一些就像语言本身提供的特殊操作符一样 的东西。而HTML
generator正是这种东西大放异彩的地方。这种感觉有点像在C++中通过模
板造出各种增强语言特性的东西一样（例如boost/loki）。</p>

<p>因为我这里只是输出简单的HTML文件，何况我对HTML的标记了解的也不多，也懒得再花经历 。所以我暂时也就将就了些土方法:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">with-output-to-string</span> <span class="p">(</span><span class="nc">stream</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">channel</span> <span class="p">(</span><span class="nv">rss-channel</span> <span class="nv">rss</span><span class="p">)))</span> <span class="c1">;取出channel对象</span>
   <span class="p">(</span><span class="nb">format</span> <span class="nc">stream</span> <span class="s">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;~a&lt;/title&gt;&lt;/head&gt;&quot;</span>
           <span class="p">(</span><span class="nv">get-property</span> <span class="nv">channel</span> <span class="ss">:|title|</span><span class="p">))</span> <span class="c1">;取出channel的title</span>
</code></pre>
</div>


<p>最后组合一些接口，即可将整个过程联系起来，导出html文件:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">cl-rss-test:test-rss-http</span> <span class="ss">:uri</span> <span class="s">&quot;/news/newshot/hotnewsrss.xml&quot;</span> 
                           <span class="ss">:host</span> <span class="s">&quot;cd.qq.com&quot;</span><span class="p">)</span>
</code></pre>
</div>


<p>然后在浏览器里查看，如图:</p>

<p><img src="/assets/res/lisp_rss/screenshot.png" alt="sample" /></p>

<h2>其他</h2>

<p>当一些代码可以工作起来的时候，就可以着手测试这批代码。然后我就用这个工具测试我 Google
Reader里订阅的一些RSS。最大的问题，就是关于HTTP重定向的问题。</p>

<p>当服务器返回301或者302的错误信息时（HTTP回应），就标示请求的URI被移动到了其他地 方，客户端需要访问新的地址。这个其实查查
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP的规范</a>
就可以轻易解决。重定向时， 新的URI被指定在Response Header里的Location域，取出来发起第二次请求即可。</p>

<p><a href="http://www.cppblog.com/Files/kevinlynx/cl-rss.tar.gz">下载代码</a></p>

<h1>参考文档</h1>

<ul>
<li>HTTP规范:
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http://www.w3.org/Protocols/rfc2616/rfc2616.html</a></li>
<li>RSS2.0规范:
<a href="http://feed2.w3.org/docs/rss2.html">http://feed2.w3.org/docs/rss2.html</a></li>
</ul>


<p>;;EOF;;</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2012/04/25/game-server-info-2/">谈谈我们的游戏逻辑服务器实现（二）</a>
      </li>
    
      <li class="post">
        <a href="/2012/04/23/game-server-info-1/">谈谈我们的游戏逻辑服务器实现（一）</a>
      </li>
    
      <li class="post">
        <a href="/2012/04/20/blog-on-github/">使用Github Page来写博客</a>
      </li>
    
      <li class="post">
        <a href="/2012/02/04/codertrace/">写了个简单的网站，codertrace.com</a>
      </li>
    
      <li class="post">
        <a href="/2011/09/29/build-blog-by-lisp/">使用Lisp搭建独立博客</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/kevinlynx">@kevinlynx</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'kevinlynx',
            count: 6,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Kevin Lynx -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'loopincodes';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
