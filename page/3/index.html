
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>loop in codes</title>
  <meta name="author" content="Kevin Lynx">

  
  <meta name="description" content="变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变
量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换
为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。 Lisp中的变量也差不多这样， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://kevinlynx.github.com/codemacro/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="loop in codes" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">loop in codes</a></h1>
  
    <h2>Kevin Lynx BLOG</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:kevinlynx.github.com/codemacro" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about.html">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/03/21/lisp-symbol/">Lisp一瞥：增强型变量Symbol</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-21T00:00:00+08:00" pubdate data-updated="true">Mar 21<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>变量，是所有编程语言里都有的语法概念。在C/C++中，变量用于标示一个内存地址，而变
量名则在语法层面上代表这个地址。当链接器最终链接我们的程序时，就将这些名字替换
为实际的地址。在其他语言中，变量虽然或多或少有其他不同的含义，但也大致如此。</p>

<p>Lisp中的变量也差不多这样，但若将variable和Lisp中的 <strong>symbol</strong> 放在一起，则多少会 带来些困惑。</p>

<h2>Lisp中的“变量&#8221;</h2>

<p>很多教授Lisp的书中，大概会简单地告诉我们可以使用如下的方式定义一个全局变量 [1]_.</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*var*</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
</div>


<p>如上代码，我们便定义了一个全局变量 <code>*var*</code> [2]_ ，它被初始化为数值1。同样，我们 还可以使用另一种基本相同的方式:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*var*</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
</div>


<p>除了全局变量，我们还可以定义局部变量。但局部变量的定义稍显麻烦（却可能是另一种
设计考虑）。定义局部变量需要使用一些宏，或者特殊运算符，例如:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">var</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~a&quot;</span> <span class="nv">var</span><span class="p">))</span>
</code></pre>
</div>


<p>好了，就这些了。Lisp中关于变量的细节，也就这些。你甚至能用你在C/C++中的经验来窥
探一切。但是，我们很快就看到了很多困惑的地方。</p>

<p>我遇到的第一个困惑的地方来源于函数，那么等我讲讲函数再来分享下坎坷。</p>

<h2>Lisp中的函数</h2>

<p>Lisp中的函数绝对不复杂，你绝对不用担心我在忽悠你 [3]_ 。作为一门函数式语言，其首要
任务就是加强函数这个东西在整个语言里的功能。如果你喜欢广阅各种与你工作不相干的
技术，你肯定已经对很多函数式语言世界中的概念略有耳闻。例如闭包，以及first class type [4]_ 。</p>

<p>Lisp中的函数就是first class type。这什么意思呢？直白来说，
<strong>Lisp中的函数和变量 没什么区别，享有同等待遇</strong> 。进一步来说，变量fn的值可以是数值1，也可以是字符串
&#8220;hello&#8221;，甚至是某个函数。这其实就是C++程序员说的functor。</p>

<p>Lisp中定义函数非常简单:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">add2</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> 
  <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
</code></pre>
</div>


<p>这样，我们就定义了一个名为add2，有1个参数，1个返回值的函数。要调用该函数时，只需 要 <code>(add2 2)</code>
即可。这简直和我们在Lisp中完成一个加法一模一样:<code>(+ 2 3)</code></p>

<p>Lisp作为一门函数式语言，其函数也能作为另一个函数的参数和返回值 [5]_</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">apply-fn</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">x</span><span class="p">))</span>
</code></pre>
</div>


<p>apply-fn函数第一个参数是一个函数，它使用funcall函数间接地调用fn指向的函数。作为
一个C++程序员，这简直太好理解了，这完全就是一个函数指针的语法糖嘛。于是，假设我 们要使用apply-fn来间接调用add2函数:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; wrong </span>
</code></pre>
</div>


<p>可是这是不对的。我们需要通过另一个特殊操作符来完成这件事:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nf">#&#39;</span><span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; right</span>
</code></pre>
</div>


<p>#&#8217;操作符用于将add2对应的函数取出来，这么说当然不大准确。Again，作为一个C++程序员
，这简直就是个取地址操作符&amp;的语法糖嘛。好吧，这么理解起来似乎没问题了。</p>

<p>Lisp中能甚至能在任何地方定义一个函数，例如我们创建一个函数，该函数返回创建出来的 函数，这是一个典型的讲解什么是 <strong>闭包</strong>
的例子:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">get-add-n</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="nf">#&#39;</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span>
</code></pre>
</div>


<p>无论如何，get-add-n函数返回一个函数，该函数是add2函数的泛型实现。它可以将你传入
的参数加上n。这些代码里使用了lambda表达式。lambda表达式直白来说，就是创建一个字
面上的函数。这又是什么意思呢？就像我们在代码中写出2，写出&#8221;hello&#8221;一样，2就是个字
面上的数字，&#8221;hello&#8221;就是个字面上的字符串 [6]_ 。</p>

<p>那么，总而言之，通过lambda创建一个函数体，然后通过#&#8217;操作符即可得到一个函数，虽然 没有名字。有了以上知识后，Again
and again，作为一个C++程序员，很快我们就能得到一
个程序：定义变量，用变量去保存一个函数，然后通过这个变量来调用这个函数。这是多么
天经地义的事，就像之前那个通过参数调用其指向的函数一样:</p>

<div class="highlight"><pre><code class="cl"><span class="c1">;; wrong </span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">fn</span> <span class="nf">#&#39;</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
</div>


<p>这样的代码是不对的，错误发生于第二行，无论你使用的Lisp实现是哪种，大概会得到如下 的错误信息:</p>

<pre><code>"The function FN is undefined."
</code></pre>

<p>老实说，这已经算是多么有迹可循的错误提示了啊。将以上代码和之前的apply-fn对比，是
多么得神似啊，可惜就是错的。这是我们遇到的第一个理解偏差导致的问题。如果你还不深
入探究，你将会在这一块遇到更多麻烦。及时地拿出你的勇气，披荆斩棘，刨根究底，绝对 是学习编程的好品质。</p>

<h2>“万恶之源“：SYMBOL</h2>

<p>上文中提到的变量函数之类，之所以会在某些时候与我们的理解发生偏差，并且总是存在些
神秘的地方无法解释。这完全是因为我们理解得太片面导致。Lisp中的Symbol可以说就是某
个变量，或者某个函数，但这太片面。Lisp中的Symbol拥有更丰富的含义。</p>

<h3>Symbol的名字</h3>

<p>就像很多语言的变量、函数名一样，Lisp中的Symbol比其他语言在命名方面更自由：
<strong>只 要位于&#8217;|&#8217;字符之间的字符串，就表示一个合法的Symbol名。</strong> 我们可以使用函数
symbol-name来获取一个Symbol的名字，例如:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;|this is a symbol name|</span><span class="p">)</span>
</code></pre>
</div>


<pre><code>输出："this is a symbol name"
</code></pre>

<p>&#8216;(quote)操作符告诉Lisp不要对其修饰的东西进行求值(evaluate)。但假如没有这个操作符
会怎样呢？后面我们将看到会怎样。</p>

<h3>Symbol本质</h3>

<p><ANSI Common Lisp\>一书中有句话真正地揭示了Symbol的本质：
<strong>Symbols are real objects</strong>
。是的，Symbols是对象，这个对象就像我们理解的C++中的对象一样，它是一个
复合的数据结构。该数据结构里包含若干域，或者通俗而言：数据成员。借用<ANSI Common Lisp\>中的一图：</p>

<blockquote><p><img src="/assets/res/lisp_symbol/symbol-obj.png" alt="image" /></p></blockquote>

<p>通过这幅图，可以揭开所有谜底。一个Symbol包含至少图中的几个域，例如Name、Value、
Function等。在Lisp中有很多函数来访问这些域，例如上文中使用到的symbol-name，这个
函数本质上就是取出一个Symbol的Name域。</p>

<h3>Symbol与Variable和Function的联系</h3>

<p>自然而然地，翻阅Lisp文档，我们会发现果然还有其他函数来访问Symbol的其他域，例如:</p>

<pre><code>symbol-function
symbol-value
symbol-package
symbol-plist
</code></pre>

<p>但是这些又与上文提到的变量和函数有什么联系呢？真相只有一个，
<strong>变量、函数粗略来 说就是Symbol的一个域，一个成员。变量对应Value域，函数对应Function域。一个Symbol 这些域有数据了，我们说它们发生了绑定(bind)。</strong>
而恰好，我们有几个函数可以用于判 定这些域是否被绑定了值:</p>

<pre><code>boundp ;判定Value域是否被绑定
fboundp;判定Function域是否被绑定
</code></pre>

<p>通过一些代码来回味以上结论:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*var*</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;*var*</span><span class="p">)</span> <span class="c1">; 返回真</span>
<span class="p">(</span><span class="nb">fboundp</span> <span class="ss">&#39;*var*</span><span class="p">)</span> <span class="c1">; 返回假</span>
<span class="p">(</span><span class="nb">defun</span> <span class="vg">*var*</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">; 定义一个名为*var*的函数，返回值即为参数</span>
<span class="p">(</span><span class="nb">fboundp</span> <span class="ss">&#39;*var*</span><span class="p">)</span> <span class="c1">; 返回真</span>
</code></pre>
</div>


<p>上面的代码简直揭秘了若干惊天地泣鬼神的真相。首先，我们使用我们熟知的defvar定义了 一个名为 <code>*var*</code>
的变量，初值为1，然后使用boundp去判定 <code>*var*</code> 的Value域是否 发生了绑定。这其实是说：
<strong>原来定义变量就是定义了一个Symbol，给变量赋值，原来就 是给Symbol的Value域赋值！</strong></p>

<p><strong>其实，Lisp中所有这些符号，都是Symbol。</strong> 什么变量，什么函数，都是浮云。上面的
例子中，紧接着用fboundp判断Symbol <code>*var*</code> 的Function域是否绑定，这个时候为假。 然后我们定义了一个名为
<code>*var*</code> 的函数，之后再判断，则已然为真。这也是为什么， <strong>在Lisp中某个函数可以和某个变量同名的原因所在。</strong>
从这段代码中我们也可以看出 defvar/defun这些操作符、宏所做事情的本质。</p>

<h3>More More More</h3>

<p>事情就这样结束了？Of course not。还有很多上文提到的疑惑没有解决。首先，Symbol是
如此复杂，那么Lisp如何决定它在不同环境下的含义呢？Symbol虽然是个对象，但它并不像
C++中的对象一样，它出现时并不指代自己！不同应用环境下，它指代的东西也不一样。这 些指代主要包括变量和函数，意思是说：
<strong>Symbol出现时，要么指的是它的Value，要么是 它的Function。</strong> 这种背地里干的事情，也算是造成迷惑的一个原因。</p>

<p>当一个Symbol出现在一个List的第一个元素时，它被处理为函数。这么说有点迷惑人，因为
它带进了Lisp中代码和数据之间的模糊边界特性。简单来说，就是当Symbol出现在一个括号
表达式(s-expression)中第一个位置时，算是个函数，例如:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">add2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; add2位于第一个位置，被当作函数处理</span>
<span class="p">(</span><span class="vg">*var*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; 这里*var*被当作函数调用，返回3</span>
</code></pre>
</div>


<p>除此之外，我能想到的其他大部分情况，一个Symbol都被指代为它的Value域，也就是被当 作变量，例如:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="vg">*var*</span> <span class="vg">*var*</span><span class="p">)</span> <span class="c1">; 这是正确的语句，返回1</span>
</code></pre>
</div>


<p>这看起来是多么古怪的代码。但是运用我们上面说的结论，便可轻易解释：表达式中第一个 <code>*var*</code>
被当作函数处理，它需要一个参数；表达式第二部分的 <code>*var*</code> 被当作变量 处理，它的值为1，然后将其作为参数传入。</p>

<p>再来说说&#8217;(quote)操作符，这个操作符用于防止其操作数被求值。而当一个Symbol出现时，
它总是会被求值，所以，我们可以分析以下代码:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="vg">*var*</span><span class="p">)</span> <span class="c1">; wrong</span>
</code></pre>
</div>


<p>这个代码并不正确，因为 <code>*var*</code> 总是会被求值，就像 <code>(*var* *var*)</code> 一样，第二 个 <code>*var*</code>
被求值，得到数字1。这里也会发生这种事情，那么最终就等同于:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; wrong</span>
</code></pre>
</div>


<p>我们试图去取数字1的Value域，而数字1并不是一个Symbol。所以，我们需要quote运算符:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">symbol-value</span> <span class="ss">&#39;*var*</span><span class="p">)</span> <span class="c1">; right</span>
</code></pre>
</div>


<p>这句代码是说，取Symbol <code>*var*</code> 本身的Value域！而不是其他什么地方。至此，我们 便可以分析以下复杂情况:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="vg">*name*</span> <span class="s">&quot;kevin lynx&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defvar</span> <span class="vg">*ref*</span> <span class="ss">&#39;*name*</span><span class="p">)</span> <span class="c1">; *ref*的Value保存的是另一个Symbol</span>
<span class="p">(</span><span class="nb">symbol-value</span> <span class="vg">*ref*</span><span class="p">)</span> <span class="c1">; 取*ref*的Value，得到*name*，再取*name*的Value</span>
</code></pre>
</div>


<p>现在，我们甚至能解释上文留下的一个问题:</p>

<div class="highlight"><pre><code class="cl"><span class="c1">;; wrong </span>
<span class="p">(</span><span class="nb">defvar</span> <span class="nv">fn</span> <span class="nf">#&#39;</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
</div>


<p>给fn的Value赋值一个函数， <code>(fn 3)</code> 当一个Symbol作为函数使用时，也就是取其
Function域来做调用。但其Function域什么也没有，我们试图将一个Symbol的Value域当作
Function来使用。如何解决这个问题？想想，symbol-function可以取到一个Symbol的 Function域:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;fn</span><span class="p">)</span> <span class="nf">#&#39;</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">fn</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
</div>


<p>通过显示地给fn的Function域赋值，而不是通过defvar隐式地对其Value域赋值，就可以使 <code>(fn 3)</code>
调用正确。还有另一个问题也能轻易解释:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="nv">add2</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; wrong</span>
</code></pre>
</div>


<p>本意是想传入add2这个Symbol的function域，但是直接这样写的话，传入的其实是add2的 Value域 [7]_
，这当然是不正确的。对比正确的写法，我们甚至能猜测#&#8217;运算符就是一个
取Symbol的Function域的运算符。进一步，我们还可以给出另一种写法:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">apply-fn</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;add2</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>


<p>深入理解事情的背后，你会发现你能写出多么灵活的代码。</p>

<h2>END</h2>

<p>关于Symbol的内容还有更多，例如Package。正确理解这些内容以及他们之间的关系，有助 于更深刻地理解Lisp。</p>

<h2>注解</h2>

<ul>
<li>[1]  在Lisp中全局变量又被称为dynamic variables</li>
<li>[2]  Lisp中按照习惯通常在为全局变量命名时会加上星号，就像我们习惯使用g_一样</li>
<li>[3]  因为我确实在忽悠你</li>
<li>[4]  first class type，有人翻译为“一等公民”，我觉得压力巨大</li>
<li>[5]  即高阶函数</li>
<li>[6]  “字面“主要是针对这些信息会被词法分析程序直接处理</li>
<li>[7]  这可能导致更多的错误</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/2011/03/13/lisp-writer/">用lisp开发博客客户端</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-03-13T00:00:00+08:00" pubdate data-updated="true">Mar 13<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近一直在学习Lisp这门语言。回头一看，基本上接近1个月了。刚开始接触Lisp是因为看
了&lt;Lisp本质&gt;，然后我发现有很多人宗教般地忠诚这门语言，于是就来了兴趣。</p>

<p><img src="/assets/res/lisp_writer/lisp_believer.png" alt="lisp_believer" /></p>

<p>当然并不是每次因为某篇写得很geek技术文章就去学习某个新的技术点。一个月时间对我来
说还是很珍贵了。但是Lisp绝对是大部分程序员都值得一学的语言（就像Haskell一样）。
我能给出的简单理由包括：</p>

<ul>
<li>大部分程序员只会命令式语言（C/C++/C Like etc)，缺乏函数式语言解决编程问题的思
想（当然Lisp不是纯函数式)</li>
<li>Lisp是仅次于Fortran的古老语言，很多优秀的语言设计思想在现代的一些语言里都找得
到</li>
<li>装B党必备</li>
</ul>


<p>另一方面，结合我一个月以来的读书和两个练习工程的实践经历，我觉得也有些理由值得你
不去学习Lisp：</p>

<ul>
<li>你会Haskell或者其他函数式语言</li>
<li>我目前还是觉得Lisp学习曲线高(大概是因为我读到的书都在应用语法层兜圈子，事实上
Lisp的语法之统一，全特么的是s-expression)，你不愿意花费这些成本</li>
<li>you are too old bo to be a B</li>
</ul>


<h2>关于这篇文档</h2>

<p>这篇博客我使用reStructuredText格式编写，然后用docutls导出为html，再然后使用这回
用lisp开发的基于metaweblog API的博客客户端，自动发布到CPPBLOG。</p>

<h2>他们怎么说Lisp</h2>

<p>我就摘录些书上的观点(历史)：</p>

<ul>
<li>1958年，John McCarthy和他的学生搞出了Lisp，包括其第一个实现，最初貌似也是以一
篇论文起头</li>
<li>Lisp可以让你做其他语言里无法做的事情(&lt;ANSI common Lisp&gt;)</li>
<li>大部分编程语言只会告诉你不能怎样做，这限制了你解决问题的思路，Lisp not (&lt;ANSI
Common Lisp&gt;)</li>
<li>Lisp让你以Lisp的思维思考问题，换到其他语言你会说：为什么X语言就不支持这个特性
呢(Once you&#8217;ve leanred Lisp, you&#8217;ll even dream in Lisp) (&lt;Land Of Lisp&gt;)</li>
<li>Lisp代码更清晰地体现你的想法(&lt;Practical Common Lisp&gt;)</li>
</ul>


<h2>And my opinion</h2>

<p>我可还没到把Lisp捧上天的地步。如果Lisp如此之好，为什么用的人不多？&lt;Land Of Lisp&gt;
里作者恰好对这个问题做了回答(bla bla bla，懒得细读)。</p>

<ul>
<li>Lisp也是一门杂和型风格的语言，函数式、命令式、面向对象，以及最被人吹捧的宏编程
&#8211;程序自己写自己</li>
<li>Lisp的语句全部以(xxx xxx)的形式出现，被称为s-expression，我看称为括号表达式还
差不多</li>
<li>Lisp每条语句都有返回值，没基础过函数式编程的同学，if语句也是有返回值的</li>
<li>函数式编程语言的一个重要特性就是闭包(closure)，这个东西用来避免全局变量实在太
geek了</li>
</ul>


<h2>开始学习Lisp</h2>

<p>Lisp不像有些语言，有个直接的机构来维护。感觉它更像C/C++一样，只有个标准，然后有
若干编译器（解释器）实现。Lisp在几十年的发展中，产生了很多种方言。方言也就是形变
神不变的语言变种，本文说的Lisp均指Lisp的方言Common Lisp。另一个比较有名的方言是
Scheme，关于各个方言的特点，&lt;Land Of Lisp&gt;里也给了一个图片：</p>

<p><img src="/assets/res/lisp_writer/dialect.png" alt="dialect" /></p>

<p>其中，最左边那只wolf就是Common Lisp，右边那只sheep就是Scheme。</p>

<p>要学习Lisp，首先就是选择方言。然后最重要的就是选择一个编译器实现。世界上知名的有
十几种实现（也许更多）。一些商业版本非常强大，甚至能编译出很小的本地代码执行文件
，不过价格也不菲。当然也有很多开源免费的实现，例如CLISP、SBCL。我选用的是SBCL。</p>

<p>SBCL交互式命令行不支持括号匹配，甚至没有输入历史。要实现这两个功能，可以装一个
lisp工具：linedit。在lisp的世界中，要获得一个lisp的库实在不是件方便的事。尤其是
这些免费的编译器实现，并不像有些语言一样，直接随编译器带个几十M的库。</p>

<p>然后就有了quicklisp这个工具。该工具就像Ubuntu系统里的软件管理器一样，你可以在
lisp里直接获取某个库。quicklisp检查该库是否存在，不存在直接从它的服务器上下载人
然后自动安装。</p>

<p>此外，在lisp的世界里，写出来的程序不再是跨OS。OS的差异由编译器实现来解决。但是，
写lisp程序却需要考虑跨编译器实现（egg hurt）。这也是个无比伤神的事，比跨OS更伤
神。因为OS就那么几个，但lisp的编译器实现，流行的也有好几个。</p>

<p>lisp的世界里，工程组织也有特殊的一套，就像makefile一样，这就是asdf。</p>

<h2>博客客户端如何实现</h2>

<p>像我们这种基本没接触过Web开发的人，可能完全没有思路去实现一个博客客户端。事实上
实现起来非常简单。</p>

<p>使用过其他博客客户端（例如Windows Live writer）的人肯定知道metaweblog API，在配
置客户端的时候需要填入。例如CPPBLOG的这个地址就是
http://www.cppblog.com/kevinlynx/services/metaweblog.aspx。这个页面展示了一些API
说明。这些API就是博客客户端和服务器进行操作通信的接口。意思是说，服务器端提供这
这些接口，我们的客户端调用这些接口即可。例如:</p>

<pre><code>blogger.deletePost，调用该接口即可删除一篇博客文章
</code></pre>

<p>但是客户端如何调用到这个接口呢？这需要通过一种新的技术（或者说标准），即 <strong>xml rpc</strong>
。rpc大家应该清楚，xml rpc其实说白了， <strong>就是把接口调用的细则塞进</strong> <strong>http
请求发给web服务器，服务器接收请求完成操作后再把结果以http回应的形式丢给客户端，
即完成了一次接口调用</strong> 。</p>

<p>至于http请求回应的细则就不提了，无非就是一些特殊格式的数据，通过tcp连接与服务器
交互这些数据。</p>

<p>所以，基本上，整个过程还是非常简单。如何来将调用细节塞进http请求，则是以xml rpc
标准来做，其格式正好是xml格式。举个例子吧:</p>

<div class="highlight"><pre><code class="xml"><span class="cp">&lt;?xml version=&#39;1.0&#39;?&gt;</span>
<span class="nt">&lt;methodCall&gt;</span>
    <span class="nt">&lt;methodName&gt;</span>title_or_id<span class="nt">&lt;/methodName&gt;</span>
        <span class="nt">&lt;params&gt;</span>
        <span class="nt">&lt;/params&gt;</span>
<span class="nt">&lt;/methodCall&gt;</span>
</code></pre>
</div>


<p>当然这部分数据之前就是若干http请求的数据。服务器回应也是以xml格式组织:</p>

<div class="highlight"><pre><code class="xml"><span class="cp">&lt;?xml version=&#39;1.0&#39;?&gt;</span>
<span class="nt">&lt;methodResponse&gt;</span>
    <span class="nt">&lt;params&gt;</span>
        <span class="nt">&lt;param&gt;</span>
            <span class="nt">&lt;value&gt;&lt;string&gt;</span>Welcome to Zope.org<span class="nt">&lt;/string&gt;&lt;/value&gt;</span>
        <span class="nt">&lt;/param&gt;</span>
    <span class="nt">&lt;/params&gt;</span>
<span class="nt">&lt;/methodResponse&gt;</span>
</code></pre>
</div>


<p>我们的博客客户端所要做的，就是把这些博客发布相关的操作封装起来提供给使用者。底层
实现主要包括http请求、xml-rpc的组织等。何况，这两部分在各个语言里都有大量的库存
在，lisp自然也有。</p>

<p>我这里直接选取了lisp的一个xml-rpc库：s-xml-rpc，基本上百来行代码就可以把各个功
能跑一遍。例如以下lisp代码就实现了通过s-xml-rpc删除CPPBLOG的一篇文章:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">delete-post</span> <span class="p">(</span><span class="nv">postid</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">rpc-call</span> 
    <span class="s">&quot;blogger.deletePost&quot;</span>
    <span class="nv">postid</span>
    <span class="s">&quot;kevinlynx&quot;</span>
    <span class="s">&quot;password&quot;</span>
    <span class="no">t</span><span class="p">))</span>
</code></pre>
</div>


<p>发布博客也很简单，根据metaweblog API接口的说明，发布博客时需要填充一个结构体。但
主要涉及到的数据仅包括：文章内容、文章标题、文章分类（可选）:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">new-post</span> <span class="p">(</span><span class="nv">title</span> <span class="nv">context</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">cates</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">rpc-call</span> 
    <span class="s">&quot;metaWeblog.newPost&quot;</span>
    <span class="s">&quot;&quot;</span>
    <span class="s">&quot;kevinlynx&quot;</span>
    <span class="s">&quot;password&quot;</span>
    <span class="p">(</span><span class="nv">new-post-struct</span> <span class="nv">title</span> <span class="nv">context</span> <span class="nv">cates</span><span class="p">)</span>
    <span class="no">t</span><span class="p">))</span>
</code></pre>
</div>


<p>值得注意的是，如果文章中有贴图，则需要事先将图片文件上传到服务器。CPPBLOG的
metaweblog API里恰有API提供:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">new-media-object</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">rpc-call</span> 
    <span class="s">&quot;metaWeblog.newMediaObject&quot;</span>
    <span class="s">&quot;&quot;</span>
    <span class="s">&quot;kevinlynx&quot;</span>
    <span class="s">&quot;password&quot;</span>
    <span class="p">(</span><span class="nv">new-media-object-struct</span> <span class="nv">filename</span><span class="p">)))</span>
</code></pre>
</div>


<p>该函数读入图片文件，然后调用metaWeblog.newMediaObject接口，即可完成上传。上传成
功后，服务器会返回该图片的URL。然后在我们的文章中就可以使用该图片了。</p>

<h2>完整实现方案</h2>

<p>仅仅将metaweblog的一些接口做封装，对于一个可以使用的博客客户端来说还远远不够。大
部分同类工具都有一个友好的GUI编辑界面。我并不打算弄一个编辑界面出来，吃力不讨好
的事情。</p>

<p>我的打算是先用其他工具对文章做排版处理，最后导出为html格式。因为CPPBLOG支持直接
发布一个html文件。然后在用这个lisp工具将整个文件作为博客文章内容发布。</p>

<p>恰好公司最近打算用reStructureText(rst)格式来编辑文档，作为熟悉手段，我决定拿这个
来练手。rst格式非常简单，同wiki命令很相似。在vim里编辑该文件非常合适，因为默认支
持。见图:</p>

<p><img src="/assets/res/lisp_writer/rst.png" alt="rst_sample" /></p>

<p>由图即可看出，rst是一种半所见即所得的格式。即：它遵循你在编辑器里的排版，同时也
通过一些tag（例如image）来控制更丰富的输出。</p>

<p>rst有很多前端工具，可以将rst文件输出，例如rst2html.py就可以输出为html。好吧，最
最终我们得到了html格式的博客文章。</p>

<p>但是如果文章中出现了图片，而图片基本上在本地，转成html后也是相对路径。我需要我的
lisp writer(cl-writer)能自动扫描文章，发现有图片的地方，就自动将图片上传。最恶心
的是上传后还得替换图片引用路径。这个工作可以在rst格式上做，也可以在结果格式html
上做。通过xml解析库解析html比直接解析rst格式更简单，并且在扩展性上更好。</p>

<p>最终这个html中图片路径替换工作只消耗了不到100行lisp代码。这在很大程度上也依赖于
s-xml库的接口设计。</p>

<p>最终封装好的发布接口如下，从这里也可以看出，函数式语言锻炼我们写出功能单一代码度
短小的接口:</p>

<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">writer-post-new</span> <span class="p">(</span><span class="nv">post-file</span> <span class="k">&amp;key</span> <span class="p">(</span><span class="nv">u</span> <span class="p">(</span><span class="nv">get-default-user</span><span class="p">))(</span><span class="nv">cates</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">read-post-file</span> <span class="nv">u</span> <span class="nv">post-file</span> <span class="nv">context</span> <span class="nv">title</span>
                  <span class="p">(</span><span class="nv">new-post</span> <span class="nv">u</span> <span class="nv">title</span> <span class="nv">context</span> <span class="nv">cates</span><span class="p">)))</span>
</code></pre>
</div>


<h2>END</h2>

<p>别指望我发布的代码能够让你一键在你的博客上留下&#8221;this is a test&#8221;，你甚至别指望它能
能够工作。但如果你本来就是一个资深的lisper，或者虽然不是lisper但却执意想看看结果
。这里我就简要说说如何让这些代码欢乐起来:</p>

<ul>
<li>OS Ubuntu10.04，下载安装SBCL，不会有问题；</li>
<li>下载安装quicklisp，官方文档hand by hand，简单不会有问题；</li>
<li>SBCL交互环境中使用quicklisp安装s-xml-rpc:</li>
</ul>


<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">ql:quickload</span> <span class="s">&quot;s-xml-rpc&quot;</span><span class="p">)</span> 
</code></pre>
</div>


<ul>
<li>装载我的代码:</li>
</ul>


<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nv">asdf:load-system</span> <span class="ss">:cl-writer</span><span class="p">)</span>
</code></pre>
</div>


<ul>
<li>在home下添加配置文件.cl-writer.lisp，配置你博客信息，例如:</li>
</ul>


<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">in-package</span> <span class="nv">cl-writer</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setf</span> <span class="vg">*default-user*</span> <span class="p">(</span><span class="nv">make-cppblog-user</span> <span class="s">&quot;账户名&quot;</span> <span class="s">&quot;密码&quot;</span><span class="p">))</span>
</code></pre>
</div>


<ul>
<li>SBCL交互环境下测试:</li>
</ul>


<div class="highlight"><pre><code class="cl"><span class="p">(</span><span class="nb">in-package</span> <span class="nv">cl-writer</span><span class="p">)</span>
<span class="p">(</span><span class="nv">new-post</span> <span class="p">(</span><span class="nv">get-default-user</span><span class="p">)</span> <span class="s">&quot;this is a test&quot;</span> <span class="s">&quot;title&quot;</span><span class="p">)</span>
</code></pre>
</div>


<p><a href="http://www.cppblog.com/Files/kevinlynx/cl-writer.tar.gz">下载代码</a></p>

<p>最后，终于敲完这篇文章，我需要通过以下步骤来发表它:</p>

<pre><code>in shell:

rst2html.py lisp_xml_rpc.rst lisp_xml_rpc.html

in SBCL:

(writer-post-new "lisp_xml_rpc.html")
</code></pre>

<p>EOF</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2012/04/25/game-server-info-2/">谈谈我们的游戏逻辑服务器实现（二）</a>
      </li>
    
      <li class="post">
        <a href="/2012/04/23/game-server-info-1/">谈谈我们的游戏逻辑服务器实现（一）</a>
      </li>
    
      <li class="post">
        <a href="/2012/04/20/blog-on-github/">使用Github Page来写博客</a>
      </li>
    
      <li class="post">
        <a href="/2012/02/04/codertrace/">写了个简单的网站，codertrace.com</a>
      </li>
    
      <li class="post">
        <a href="/2011/09/29/build-blog-by-lisp/">使用Lisp搭建独立博客</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/kevinlynx">@kevinlynx</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'kevinlynx',
            count: 6,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Kevin Lynx -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'loopincodes';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
