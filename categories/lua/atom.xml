<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lua | loop in codes]]></title>
  <link href="http://kevinlynx.github.com/codemacro/categories/lua/atom.xml" rel="self"/>
  <link href="http://kevinlynx.github.com/codemacro/"/>
  <updated>2012-04-28T11:52:59+08:00</updated>
  <id>http://kevinlynx.github.com/codemacro/</id>
  <author>
    <name><![CDATA[Kevin Lynx]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[传递Lua函数到C/C++中]]></title>
    <link href="http://kevinlynx.github.com/codemacro/2011/05/09/lua-function-arg/"/>
    <updated>2011-05-09T00:00:00+08:00</updated>
    <id>http://kevinlynx.github.com/codemacro/2011/05/09/lua-function-arg</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>在Lua中，因为函数也是第一类值，所以会出现将函数作为另一个函数的参数，或者函数作
为函数的返回值。这种机制在很多地方都能代码更灵活更简洁，例如:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nb">table.sort</span><span class="p">(</span><span class="n">table</span> <span class="p">[,</span><span class="n">comp</span><span class="p">])</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>这里的comp就要求传入一个函数，我们在调用时，大概会有如下形式:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nb">table.sort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">comp</span><span class="p">)</span> <span class="c1">-- 直接写函数名</span>
<span class="nb">table.sort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">local_comp</span><span class="p">)</span> <span class="c1">-- 某个局部函数</span>
<span class="nb">table.sort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">xxx</span> <span class="k">end</span> <span class="p">)</span> <span class="c1">-- 临时构造一个匿名函数</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>其中最后一种方式最为灵活，任意时候在需要的时候构造一个匿名函数。这种在Lua自身的
环境中使用，自然没有问题。但是，当我们在C/C++中注册一些函数到Lua环境中，而这些 函数也需要使用函数参数的时候，问题就出来了。</p>

<!-- more -->


<p>Lua本身是不支持将Lua函数作为函数参数传入C/C++的，不管这个想要传入的函数是全局的
、局部的、或者匿名的（匿名的本质上也算局部的）。一般情况下，我们唯一的交互方式，
不是传入一个函数，而是一个全局函数名。C/C++保存这个函数名，在需要回调Lua的时候，
就在Lua全局表中找到这个函数（根据函数名），然后再调用之。情况大致如下:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">function</span> <span class="nf">lua_func</span> <span class="p">()</span> <span class="n">xxx</span> <span class="k">end</span>
<span class="n">cfunc</span><span class="p">(</span><span class="n">lua_func</span><span class="p">)</span> <span class="c1">-- wrong</span>
<span class="n">cfunc</span><span class="p">(</span><span class="s2">&quot;</span><span class="s">lua_func&quot;</span><span class="p">)</span> <span class="c1">-- right</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>我们这回的脚本模块，策划会大量使用需要回调函数的C/C++函数。显然，创建大量的全局 函数，先是从写代码的角度看，就是很伤神的。</p>

<h2>解决</h2>

<p>我们最终需要的方式，大概如下:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">cfunc</span><span class="p">(</span><span class="n">lua_func</span><span class="p">)</span> <span class="c1">-- ok</span>
<span class="n">cfunc</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="n">xxx</span> <span class="k">end</span><span class="p">)</span> <span class="c1">-- ok</span>
<span class="kd">local</span> <span class="n">xxx</span> <span class="o">=</span> <span class="k">function</span> <span class="p">()</span> <span class="n">xxx</span> <span class="k">end</span>
<span class="n">cfunc</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span> <span class="c1">-- ok</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>要解决这个问题，我的思路是直接在Lua层做一些包装。因为C/C++那边仅支持传入一个全局
函数名（当然不一定得全局的，根据实际情况，可能在其他自己构造的表里也行），也就是
一个字符串，所以我的思路就是将Lua函数和一个唯一的字符串做映射。:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">function</span> <span class="nf">wrap</span> <span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">generate_id</span><span class="p">()</span>
    <span class="kd">local</span> <span class="n">fn_s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">__callback_fn&quot;</span><span class="p">..</span><span class="n">id</span>
    <span class="nb">_G</span><span class="p">[</span><span class="n">fn_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span>
    <span class="k">return</span> <span class="n">fn_s</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>这个wrap函数，就是将一个函数在全局表里映射到一个字符串上，那么在使用时:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">cfunc</span><span class="p">(</span><span class="n">wrap</span><span class="p">(</span><span class="k">function</span> <span class="p">()</span> <span class="n">xxx</span> <span class="k">end</span><span class="p">))</span>
<span class="n">cfunc</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">fn_name</span><span class="p">,</span> <span class="n">xxx</span><span class="p">);</span> <span class="c1">-- cfunc的原型</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>cfunc是C/C++方注册进Lua的函数，它的原型很中规中矩，即：只接收一个函数名，一个字
符串，如之前所说，C/C++要调用这个回调函数时，就根据这个字符串去查找对应的函数。
脚本方在调用时，如果想传入一个匿名函数了，就调用wrap函数包装一下即可。</p>

<h2>一个改进</h2>

<p>上面的方法有个很严重的问题，在多次调用wrap函数后，将导致全局表也随之膨胀。我们需
要想办法在C/C++完成回调后，来清除wrap建立的数据。这个工作当然可以放到C/C++来进行
，例如每次发生回调后，就设置下全局表。但这明显是不对的，因为违背了接口的设计原则
，这个额外的机制是在Lua里添加的，那么责任也最好由Lua来负。要解决这个问题，就可以
使用Lua的metamethods机制。这个机制可以在Lua内部发生特定事件时，让应用层得到通知。
这里，我们需要关注__call事件。</p>

<p>Lua中只要有__call metamethod的值，均可被当作函数调用。例如:</p>

<pre><code>ab(1, 2) 
</code></pre>

<p>这里这个函数调用形式，Lua就会去找ab是否有__call metamethod，如果有，则调用它。这
个事实暗示我们，一个table也可以被调用。一个改进的wrap函数如下:</p>

<p><div class="highlight"><pre><code class="lua"><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">local</span> <span class="k">function</span> <span class="nf">create_callback_table</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">t</span><span class="p">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">fn</span>
    <span class="nb">setmetatable</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">{</span><span class="n">__call</span> <span class="o">=</span>  <span class="c1">-- 关注__call</span>
        <span class="k">function</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">...)</span> <span class="c1">-- 在t(xx)时，将调用到这个函数</span>
            <span class="n">func</span><span class="p">.</span><span class="n">callback</span> <span class="p">(...)</span> <span class="c1">-- 真正的回调</span>
            <span class="n">del_callback</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="c1">-- 回调完毕，清除wrap建立的数据</span>
        <span class="k">end</span> <span class="p">})</span>
    <span class="k">return</span> <span class="n">t</span>
<span class="k">end</span>

<span class="k">function</span> <span class="nf">wrap</span> <span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">id</span> <span class="o">=</span> <span class="n">generate_func_id</span><span class="p">()</span> <span class="c1">-- 产生唯一的id</span>
    <span class="kd">local</span> <span class="n">fn_s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="s">_callback_fn&quot;</span><span class="p">..</span><span class="n">id</span>
    <span class="nb">_G</span><span class="p">[</span><span class="n">fn_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_callback_table</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn_s</span><span class="p">)</span> <span class="c1">-- _G[fn_s]对应的是一个表</span>
    <span class="k">return</span> <span class="n">fn_s</span>
<span class="k">end</span>
<span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</code></pre>
</div>
</p>

<p>在我们的C/C++程序中，依然如往常一样，先是从_G里取出函数名对应的对象。虽然这个对
象现在已经是一个table。然后lua_call。</p>

<p>上面的代码是否会在原有基础上增加不可接受的性能代价？虽然我没有做过实际测试，但是 从表明看来，排除meta
table在Lua里的代价，也就多了几次Lua函数调用。</p>

<p>最后，感叹一下，Lua里的table及metatable机制，实在非常强大。这种强大不是功能堆砌
出来的强大，而是简单东西组合出来的强大。其背后的设计思想，着实让人佩服。</p>

<p><strong>4.26.2011 Update</strong></p>

<p>之前的文中说“Lua本身是不支持将Lua函数作为函数参数传入C/C++的“，这句话严格来说不
正确（由某网友评论）。假设函数cfun由c/c++注册，我们是可以编写如下代码的:</p>

<pre><code>cfunc(print) -- 传入Lua函数
</code></pre>

<p>但是问题在于，我们无法取出这个函数并保存在c/c++方。Lua提供了一些接口用于取cfunc
的参数，例如luaL_checknumber（封装lua_tonumber）。但没有类似luaL_checkfunction的
接口。Lua中的table有同样的问题。究其原因，主要是Lua中的函数没有直接的c/c++数据结 构对应。</p>

<p>;; END</p>
]]></content>
  </entry>
  
</feed>
